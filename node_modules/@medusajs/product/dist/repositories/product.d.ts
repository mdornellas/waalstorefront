import { Product } from "../models";
import { Context, DAL, ProductTypes, WithRequiredProperty } from "@medusajs/types";
import { SqlEntityManager } from "@mikro-orm/postgresql";
import { DALUtils } from "@medusajs/utils";
import { ProductServiceTypes } from "../types/services";
export declare class ProductRepository extends DALUtils.MikroOrmAbstractBaseRepository<Product> {
    protected readonly manager_: SqlEntityManager;
    constructor({ manager }: {
        manager: SqlEntityManager;
    });
    find(findOptions?: DAL.FindOptions<Product & {
        q?: string;
    }>, context?: Context): Promise<Product[]>;
    findAndCount(findOptions?: DAL.FindOptions<Product & {
        q?: string;
    }>, context?: Context): Promise<[Product[], number]>;
    /**
     * In order to be able to have a strict not in categories, and prevent a product
     * to be return in the case it also belongs to other categories, we need to
     * first find all products that are in the categories, and then exclude them
     */
    protected mutateNotInCategoriesConstraints(findOptions?: DAL.FindOptions<Product>, context?: Context): Promise<void>;
    delete(ids: string[], context?: Context): Promise<void>;
    create(data: WithRequiredProperty<ProductTypes.CreateProductOnlyDTO, "status">[], context?: Context): Promise<Product[]>;
    update(data: WithRequiredProperty<ProductServiceTypes.UpdateProductDTO, "id">[], context?: Context): Promise<Product[]>;
    protected getFreeTextSearchConstraints(q: string): ({
        description: {
            $ilike: string;
        };
        title?: undefined;
        collection?: undefined;
        variants?: undefined;
    } | {
        title: {
            $ilike: string;
        };
        description?: undefined;
        collection?: undefined;
        variants?: undefined;
    } | {
        collection: {
            title: {
                $ilike: string;
            };
        };
        description?: undefined;
        title?: undefined;
        variants?: undefined;
    } | {
        variants: {
            $or: ({
                title: {
                    $ilike: string;
                };
                sku?: undefined;
            } | {
                sku: {
                    $ilike: string;
                };
                title?: undefined;
            })[];
        };
        description?: undefined;
        title?: undefined;
        collection?: undefined;
    })[];
}
