"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProductOptionRepository = void 0;
const utils_1 = require("@medusajs/utils");
const core_1 = require("@mikro-orm/core");
const _models_1 = require("../models");
// eslint-disable-next-line max-len
class ProductOptionRepository extends utils_1.DALUtils.MikroOrmAbstractBaseRepository {
    constructor({ manager }) {
        // @ts-ignore
        // eslint-disable-next-line prefer-rest-params
        super(...arguments);
        this.manager_ = manager;
    }
    async find(findOptions = { where: {} }, context = {}) {
        const manager = this.getActiveManager(context);
        const findOptions_ = { ...findOptions };
        findOptions_.options ?? (findOptions_.options = {});
        Object.assign(findOptions_.options, {
            strategy: core_1.LoadStrategy.SELECT_IN,
        });
        return await manager.find(_models_1.ProductOption, findOptions_.where, findOptions_.options);
    }
    async findAndCount(findOptions = { where: {} }, context = {}) {
        const manager = this.getActiveManager(context);
        const findOptions_ = { ...findOptions };
        findOptions_.options ?? (findOptions_.options = {});
        Object.assign(findOptions_.options, {
            strategy: core_1.LoadStrategy.SELECT_IN,
        });
        return await manager.findAndCount(_models_1.ProductOption, findOptions_.where, findOptions_.options);
    }
    async delete(ids, context = {}) {
        const manager = this.getActiveManager(context);
        await manager.nativeDelete(_models_1.ProductOption, { id: { $in: ids } }, {});
    }
    async create(data, context = {}) {
        const manager = this.getActiveManager(context);
        const productIds = [];
        data.forEach((d) => d.product_id && productIds.push(d.product_id));
        const existingProducts = await manager.find(_models_1.Product, {
            id: { $in: productIds },
        });
        const existingProductsMap = new Map(existingProducts.map((product) => [
            product.id,
            product,
        ]));
        const productOptions = data.map((optionData) => {
            const productId = optionData.product_id;
            delete optionData.product_id;
            if (productId) {
                const product = existingProductsMap.get(productId);
                optionData.product_id = product?.id;
            }
            return manager.create(_models_1.ProductOption, optionData);
        });
        manager.persist(productOptions);
        return productOptions;
    }
    async update(data, context = {}) {
        const manager = this.getActiveManager(context);
        const optionIds = data.map((optionData) => optionData.id);
        const existingOptions = await this.find({
            where: {
                id: {
                    $in: optionIds,
                },
            },
        }, context);
        const existingOptionsMap = new Map(existingOptions.map((option) => [
            option.id,
            option,
        ]));
        const productOptions = data.map((optionData) => {
            const existingOption = existingOptionsMap.get(optionData.id);
            if (!existingOption) {
                throw new utils_1.MedusaError(utils_1.MedusaError.Types.NOT_FOUND, `ProductOption with id "${optionData.id}" not found`);
            }
            return manager.assign(existingOption, optionData);
        });
        manager.persist(productOptions);
        return productOptions;
    }
    async upsert(data, context = {}) {
        const manager = this.getActiveManager(context);
        const optionIds = data.map((optionData) => optionData.id).filter((o) => o);
        let existingOptions;
        let existingOptionsMap = new Map();
        if (optionIds.length) {
            existingOptions = await this.find({
                where: {
                    id: {
                        $in: optionIds,
                    },
                },
            }, context);
            existingOptionsMap = new Map(existingOptions.map((option) => [option.id, option]));
        }
        const upsertedOptions = [];
        const optionsToCreate = [];
        const optionsToUpdate = [];
        data.forEach((option) => {
            const existingOption = existingOptionsMap.get(option.id);
            if (existingOption) {
                const updatedOption = manager.assign(existingOption, option);
                optionsToUpdate.push(updatedOption);
            }
            else {
                const newOption = manager.create(_models_1.ProductOption, option);
                optionsToCreate.push(newOption);
            }
        });
        if (optionsToCreate.length) {
            manager.persist(optionsToCreate);
            upsertedOptions.push(...optionsToCreate);
        }
        if (optionsToUpdate.length) {
            manager.persist(optionsToUpdate);
            upsertedOptions.push(...optionsToUpdate);
        }
        return upsertedOptions;
    }
}
exports.ProductOptionRepository = ProductOptionRepository;
