"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProductRepository = void 0;
const _models_1 = require("../models");
const core_1 = require("@mikro-orm/core");
const utils_1 = require("@medusajs/utils");
// eslint-disable-next-line max-len
class ProductRepository extends utils_1.DALUtils.MikroOrmAbstractBaseRepository {
    constructor({ manager }) {
        // @ts-ignore
        // eslint-disable-next-line prefer-rest-params
        super(...arguments);
        this.manager_ = manager;
    }
    async find(findOptions = { where: {} }, context = {}) {
        const manager = this.getActiveManager(context);
        const findOptions_ = { ...findOptions };
        findOptions_.options ?? (findOptions_.options = {});
        Object.assign(findOptions_.options, {
            strategy: core_1.LoadStrategy.SELECT_IN,
        });
        await this.mutateNotInCategoriesConstraints(findOptions_);
        this.applyFreeTextSearchFilters(findOptions_, this.getFreeTextSearchConstraints);
        return await manager.find(_models_1.Product, findOptions_.where, findOptions_.options);
    }
    async findAndCount(findOptions = { where: {} }, context = {}) {
        const manager = this.getActiveManager(context);
        const findOptions_ = { ...findOptions };
        findOptions_.options ?? (findOptions_.options = {});
        Object.assign(findOptions_.options, {
            strategy: core_1.LoadStrategy.SELECT_IN,
        });
        await this.mutateNotInCategoriesConstraints(findOptions_);
        this.applyFreeTextSearchFilters(findOptions_, this.getFreeTextSearchConstraints);
        return await manager.findAndCount(_models_1.Product, findOptions_.where, findOptions_.options);
    }
    /**
     * In order to be able to have a strict not in categories, and prevent a product
     * to be return in the case it also belongs to other categories, we need to
     * first find all products that are in the categories, and then exclude them
     */
    async mutateNotInCategoriesConstraints(findOptions = { where: {} }, context = {}) {
        const manager = this.getActiveManager(context);
        if ("categories" in findOptions.where &&
            findOptions.where.categories?.id?.["$nin"]) {
            const productsInCategories = await manager.find(_models_1.Product, {
                categories: {
                    id: { $in: findOptions.where.categories.id["$nin"] },
                },
            }, {
                fields: ["id"],
            });
            const productIds = productsInCategories.map((product) => product.id);
            if (productIds.length) {
                findOptions.where.id = { $nin: productIds };
                delete findOptions.where.categories?.id;
                if (Object.keys(findOptions.where.categories).length === 0) {
                    delete findOptions.where.categories;
                }
            }
        }
    }
    async delete(ids, context = {}) {
        const manager = this.getActiveManager(context);
        await manager.nativeDelete(_models_1.Product, { id: { $in: ids } }, {});
    }
    async create(data, context = {}) {
        const manager = this.getActiveManager(context);
        const products = data.map((product) => {
            return manager.create(_models_1.Product, product);
        });
        manager.persist(products);
        return products;
    }
    async update(data, context = {}) {
        let categoryIds = [];
        let tagIds = [];
        const collectionIds = [];
        const typeIds = [];
        // TODO: use the getter method (getActiveManager)
        const manager = this.getActiveManager(context);
        data.forEach((productData) => {
            categoryIds = categoryIds.concat(productData?.categories?.map((c) => c.id) || []);
            tagIds = tagIds.concat(productData?.tags?.map((c) => c.id) || []);
            if (productData.collection_id) {
                collectionIds.push(productData.collection_id);
            }
            if (productData.type_id) {
                typeIds.push(productData.type_id);
            }
        });
        const productsToUpdate = await manager.find(_models_1.Product, {
            id: data.map((updateData) => updateData.id),
        }, {
            populate: ["tags", "categories"],
        });
        const collectionsToAssign = collectionIds.length
            ? await manager.find(_models_1.ProductCollection, {
                id: collectionIds,
            })
            : [];
        const typesToAssign = typeIds.length
            ? await manager.find(_models_1.ProductType, {
                id: typeIds,
            })
            : [];
        const categoriesToAssign = categoryIds.length
            ? await manager.find(_models_1.ProductCategory, {
                id: categoryIds,
            })
            : [];
        const tagsToAssign = tagIds.length
            ? await manager.find(_models_1.ProductTag, {
                id: tagIds,
            })
            : [];
        const categoriesToAssignMap = new Map(categoriesToAssign.map((category) => [category.id, category]));
        const tagsToAssignMap = new Map(tagsToAssign.map((tag) => [tag.id, tag]));
        const collectionsToAssignMap = new Map(collectionsToAssign.map((collection) => [collection.id, collection]));
        const typesToAssignMap = new Map(typesToAssign.map((type) => [type.id, type]));
        const productsToUpdateMap = new Map(productsToUpdate.map((product) => [product.id, product]));
        const products = await (0, utils_1.promiseAll)(data.map(async (updateData) => {
            const product = productsToUpdateMap.get(updateData.id);
            if (!product) {
                throw new utils_1.MedusaError(utils_1.MedusaError.Types.NOT_FOUND, `Product with id "${updateData.id}" not found`);
            }
            const { categories: categoriesData = [], tags: tagsData = [], collection_id: collectionId, type_id: typeId, } = updateData;
            delete updateData?.categories;
            delete updateData?.tags;
            delete updateData?.collection_id;
            delete updateData?.type_id;
            if ((0, utils_1.isDefined)(categoriesData)) {
                await product.categories.init();
                for (const categoryData of categoriesData) {
                    const productCategory = categoriesToAssignMap.get(categoryData.id);
                    if (productCategory) {
                        product.categories.add(productCategory);
                    }
                }
                const categoryIdsToAssignSet = new Set(categoriesData.map((cd) => cd.id));
                const categoriesToDelete = product.categories
                    .getItems()
                    .filter((existingCategory) => !categoryIdsToAssignSet.has(existingCategory.id));
                product.categories.remove(categoriesToDelete);
            }
            if ((0, utils_1.isDefined)(tagsData)) {
                await product.tags.init();
                for (const tagData of tagsData) {
                    let productTag = tagsToAssignMap.get(tagData.id);
                    if (tagData instanceof _models_1.ProductTag) {
                        productTag = tagData;
                    }
                    if (productTag) {
                        product.tags.add(productTag);
                    }
                }
                const tagIdsToAssignSet = new Set(tagsData.map((cd) => cd.id));
                const tagsToDelete = product.tags
                    .getItems()
                    .filter((existingTag) => !tagIdsToAssignSet.has(existingTag.id));
                product.tags.remove(tagsToDelete);
            }
            if ((0, utils_1.isDefined)(collectionId)) {
                const collection = collectionsToAssignMap.get(collectionId);
                product.collection = collection || null;
            }
            if ((0, utils_1.isDefined)(typeId)) {
                const type = typesToAssignMap.get(typeId);
                if (type) {
                    product.type = type;
                }
            }
            return manager.assign(product, updateData);
        }));
        manager.persist(products);
        return products;
    }
    getFreeTextSearchConstraints(q) {
        return [
            {
                description: {
                    $ilike: `%${q}%`,
                },
            },
            {
                title: {
                    $ilike: `%${q}%`,
                },
            },
            {
                collection: {
                    title: {
                        $ilike: `%${q}%`,
                    },
                },
            },
            {
                variants: {
                    $or: [
                        {
                            title: {
                                $ilike: `%${q}%`,
                            },
                        },
                        {
                            sku: {
                                $ilike: `%${q}%`,
                            },
                        },
                    ],
                },
            },
        ];
    }
}
exports.ProductRepository = ProductRepository;
