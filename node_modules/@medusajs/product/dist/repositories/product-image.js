"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProductImageRepository = void 0;
const core_1 = require("@mikro-orm/core");
const _models_1 = require("../models");
const utils_1 = require("@medusajs/utils");
// eslint-disable-next-line max-len
class ProductImageRepository extends utils_1.DALUtils.MikroOrmAbstractBaseRepository {
    constructor({ manager }) {
        // @ts-ignore
        // eslint-disable-next-line prefer-rest-params
        super(...arguments);
        this.manager_ = manager;
    }
    async find(findOptions = { where: {} }, context = {}) {
        const manager = this.getActiveManager(context);
        const findOptions_ = { ...findOptions };
        findOptions_.options ?? (findOptions_.options = {});
        Object.assign(findOptions_.options, {
            strategy: core_1.LoadStrategy.SELECT_IN,
        });
        return await manager.find(_models_1.Image, findOptions_.where, findOptions_.options);
    }
    async findAndCount(findOptions = { where: {} }, context = {}) {
        const manager = this.getActiveManager(context);
        const findOptions_ = { ...findOptions };
        findOptions_.options ?? (findOptions_.options = {});
        Object.assign(findOptions_.options, {
            strategy: core_1.LoadStrategy.SELECT_IN,
        });
        return await manager.findAndCount(_models_1.Image, findOptions_.where, findOptions_.options);
    }
    async upsert(urls, context = {}) {
        const manager = this.getActiveManager(context);
        const existingImages = await this.find({
            where: {
                url: {
                    $in: urls,
                },
            },
        }, context);
        const existingImagesMap = new Map(existingImages.map((img) => [img.url, img]));
        const upsertedImgs = [];
        const imageToCreate = [];
        urls.forEach((url) => {
            const aImg = existingImagesMap.get(url);
            if (aImg) {
                upsertedImgs.push(aImg);
            }
            else {
                const newImg = manager.create(_models_1.Image, { url });
                imageToCreate.push(newImg);
            }
        });
        if (imageToCreate.length) {
            manager.persist(imageToCreate);
            upsertedImgs.push(...imageToCreate);
        }
        return upsertedImgs;
    }
    async delete(ids, context = {}) {
        const manager = this.getActiveManager(context);
        await manager.nativeDelete(_models_1.Product, { id: { $in: ids } }, {});
    }
    async create(data, context = {}) {
        throw new Error("Method not implemented.");
    }
}
exports.ProductImageRepository = ProductImageRepository;
