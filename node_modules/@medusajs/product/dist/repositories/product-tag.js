"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProductTagRepository = void 0;
const core_1 = require("@mikro-orm/core");
const _models_1 = require("../models");
const utils_1 = require("@medusajs/utils");
class ProductTagRepository extends utils_1.DALUtils.MikroOrmBaseRepository {
    constructor({ manager }) {
        // @ts-ignore
        // eslint-disable-next-line prefer-rest-params
        super(...arguments);
        this.manager_ = manager;
    }
    async find(findOptions = { where: {} }, context = {}) {
        const manager = this.getActiveManager(context);
        const findOptions_ = { ...findOptions };
        findOptions_.options ?? (findOptions_.options = {});
        Object.assign(findOptions_.options, {
            strategy: core_1.LoadStrategy.SELECT_IN,
        });
        return await manager.find(_models_1.ProductTag, findOptions_.where, findOptions_.options);
    }
    async findAndCount(findOptions = { where: {} }, context = {}) {
        const manager = this.getActiveManager(context);
        const findOptions_ = { ...findOptions };
        findOptions_.options ?? (findOptions_.options = {});
        Object.assign(findOptions_.options, {
            strategy: core_1.LoadStrategy.SELECT_IN,
        });
        return await manager.findAndCount(_models_1.ProductTag, findOptions_.where, findOptions_.options);
    }
    async create(data, context = {}) {
        const manager = this.getActiveManager(context);
        const productTags = data.map((tagData) => {
            return manager.create(_models_1.ProductTag, tagData);
        });
        manager.persist(productTags);
        return productTags;
    }
    async update(data, context = {}) {
        const manager = this.getActiveManager(context);
        const tagIds = data.map((tagData) => tagData.id);
        const existingTags = await this.find({
            where: {
                id: {
                    $in: tagIds,
                },
            },
        }, context);
        const existingTagsMap = new Map(existingTags.map((tag) => [tag.id, tag]));
        const productTags = data.map((tagData) => {
            const existingTag = existingTagsMap.get(tagData.id);
            if (!existingTag) {
                throw new utils_1.MedusaError(utils_1.MedusaError.Types.NOT_FOUND, `ProductTag with id "${tagData.id}" not found`);
            }
            return manager.assign(existingTag, tagData);
        });
        manager.persist(productTags);
        return productTags;
    }
    async upsert(tags, context = {}) {
        const manager = this.getActiveManager(context);
        const tagsValues = tags.map((tag) => tag.value);
        const existingTags = await this.find({
            where: {
                value: {
                    $in: tagsValues,
                },
            },
        }, context);
        const existingTagsMap = new Map(existingTags.map((tag) => [tag.value, tag]));
        const upsertedTags = [];
        const tagsToCreate = [];
        const tagsToUpdate = [];
        tags.forEach((tag) => {
            const aTag = existingTagsMap.get(tag.value);
            if (aTag) {
                const updatedTag = manager.assign(aTag, tag);
                tagsToUpdate.push(updatedTag);
            }
            else {
                const newTag = manager.create(_models_1.ProductTag, tag);
                tagsToCreate.push(newTag);
            }
        });
        if (tagsToCreate.length) {
            manager.persist(tagsToCreate);
            upsertedTags.push(...tagsToCreate);
        }
        if (tagsToUpdate.length) {
            manager.persist(tagsToUpdate);
            upsertedTags.push(...tagsToUpdate);
        }
        return upsertedTags;
    }
    async delete(ids, context = {}) {
        const manager = this.getActiveManager(context);
        await manager.nativeDelete(_models_1.ProductTag, { id: { $in: ids } }, {});
    }
}
exports.ProductTagRepository = ProductTagRepository;
