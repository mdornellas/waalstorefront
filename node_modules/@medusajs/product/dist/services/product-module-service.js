"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@medusajs/types");
const product_category_1 = require("../types/services/product-category");
const product_collection_1 = require("../types/services/product-collection");
const product_1 = require("../types/services/product");
const utils_1 = require("@medusajs/utils");
const joiner_config_1 = require("./../joiner-config");
class ProductModuleService {
    constructor({ baseRepository, productService, productVariantService, productTagService, productCategoryService, productCollectionService, productImageService, productTypeService, productOptionService, eventBusModuleService, }, moduleDeclaration) {
        this.moduleDeclaration = moduleDeclaration;
        this.baseRepository_ = baseRepository;
        this.productService_ = productService;
        this.productVariantService_ = productVariantService;
        this.productTagService_ = productTagService;
        this.productCategoryService_ = productCategoryService;
        this.productCollectionService_ = productCollectionService;
        this.productImageService_ = productImageService;
        this.productTypeService_ = productTypeService;
        this.productOptionService_ = productOptionService;
        this.eventBusModuleService_ = eventBusModuleService;
    }
    __joinerConfig() {
        return joiner_config_1.joinerConfig;
    }
    async list(filters = {}, config = {}, sharedContext = {}) {
        const products = await this.productService_.list(filters, config, sharedContext);
        return JSON.parse(JSON.stringify(products));
    }
    async retrieve(productId, config = {}, sharedContext = {}) {
        const product = await this.productService_.retrieve(productId, config, sharedContext);
        return JSON.parse(JSON.stringify(product));
    }
    async listAndCount(filters = {}, config = {}, sharedContext = {}) {
        const [products, count] = await this.productService_.listAndCount(filters, config, sharedContext);
        return [JSON.parse(JSON.stringify(products)), count];
    }
    async retrieveVariant(productVariantId, config = {}, sharedContext = {}) {
        const productVariant = await this.productVariantService_.retrieve(productVariantId, config, sharedContext);
        return JSON.parse(JSON.stringify(productVariant));
    }
    async listVariants(filters = {}, config = {}, sharedContext = {}) {
        const variants = await this.productVariantService_.list(filters, config, sharedContext);
        return JSON.parse(JSON.stringify(variants));
    }
    async listAndCountVariants(filters = {}, config = {}, sharedContext = {}) {
        const [variants, count] = await this.productVariantService_.listAndCount(filters, config, sharedContext);
        return [JSON.parse(JSON.stringify(variants)), count];
    }
    async retrieveTag(tagId, config = {}, sharedContext = {}) {
        const productTag = await this.productTagService_.retrieve(tagId, config, sharedContext);
        return JSON.parse(JSON.stringify(productTag));
    }
    async listTags(filters = {}, config = {}, sharedContext = {}) {
        const tags = await this.productTagService_.list(filters, config, sharedContext);
        return JSON.parse(JSON.stringify(tags));
    }
    async listAndCountTags(filters = {}, config = {}, sharedContext = {}) {
        const [tags, count] = await this.productTagService_.listAndCount(filters, config, sharedContext);
        return [JSON.parse(JSON.stringify(tags)), count];
    }
    async createTags(data, sharedContext = {}) {
        const productTags = await this.productTagService_.create(data, sharedContext);
        return JSON.parse(JSON.stringify(productTags));
    }
    async updateTags(data, sharedContext = {}) {
        const productTags = await this.productTagService_.update(data, sharedContext);
        return JSON.parse(JSON.stringify(productTags));
    }
    async deleteTags(productTagIds, sharedContext = {}) {
        await this.productTagService_.delete(productTagIds, sharedContext);
    }
    async retrieveType(typeId, config = {}, sharedContext = {}) {
        const productType = await this.productTypeService_.retrieve(typeId, config, sharedContext);
        return JSON.parse(JSON.stringify(productType));
    }
    async listTypes(filters = {}, config = {}, sharedContext = {}) {
        const types = await this.productTypeService_.list(filters, config, sharedContext);
        return JSON.parse(JSON.stringify(types));
    }
    async listAndCountTypes(filters = {}, config = {}, sharedContext = {}) {
        const [types, count] = await this.productTypeService_.listAndCount(filters, config, sharedContext);
        return [JSON.parse(JSON.stringify(types)), count];
    }
    async createTypes(data, sharedContext = {}) {
        const productTypes = await this.productTypeService_.create(data, sharedContext);
        return JSON.parse(JSON.stringify(productTypes));
    }
    async updateTypes(data, sharedContext = {}) {
        const productTypes = await this.productTypeService_.update(data, sharedContext);
        return JSON.parse(JSON.stringify(productTypes));
    }
    async deleteTypes(productTypeIds, sharedContext = {}) {
        await this.productTypeService_.delete(productTypeIds, sharedContext);
    }
    async retrieveOption(optionId, config = {}, sharedContext = {}) {
        const productOptions = await this.productOptionService_.retrieve(optionId, config, sharedContext);
        return JSON.parse(JSON.stringify(productOptions));
    }
    async listOptions(filters = {}, config = {}, sharedContext = {}) {
        const productOptions = await this.productOptionService_.list(filters, config, sharedContext);
        return JSON.parse(JSON.stringify(productOptions));
    }
    async listAndCountOptions(filters = {}, config = {}, sharedContext = {}) {
        const [productOptions, count] = await this.productOptionService_.listAndCount(filters, config, sharedContext);
        return [JSON.parse(JSON.stringify(productOptions)), count];
    }
    async createOptions(data, sharedContext = {}) {
        const productOptions = await this.productOptionService_.create(data, sharedContext);
        return await this.baseRepository_.serialize(productOptions, {
            populate: true,
        });
    }
    async updateOptions(data, sharedContext = {}) {
        const productOptions = await this.productOptionService_.update(data, sharedContext);
        return await this.baseRepository_.serialize(productOptions, {
            populate: true,
        });
    }
    async deleteOptions(productOptionIds, sharedContext = {}) {
        await this.productOptionService_.delete(productOptionIds, sharedContext);
    }
    async retrieveCollection(productCollectionId, config = {}, sharedContext = {}) {
        const productCollection = await this.productCollectionService_.retrieve(productCollectionId, config, sharedContext);
        return JSON.parse(JSON.stringify(productCollection));
    }
    async listCollections(filters = {}, config = {}, sharedContext = {}) {
        const collections = await this.productCollectionService_.list(filters, config, sharedContext);
        return JSON.parse(JSON.stringify(collections));
    }
    async listAndCountCollections(filters = {}, config = {}, sharedContext = {}) {
        const collections = await this.productCollectionService_.listAndCount(filters, config, sharedContext);
        return JSON.parse(JSON.stringify(collections));
    }
    async createCollections(data, sharedContext = {}) {
        const productCollections = await this.productCollectionService_.create(data, sharedContext);
        await this.eventBusModuleService_?.emit(productCollections.map(({ id }) => ({
            eventName: product_collection_1.ProductCollectionEvents.COLLECTION_CREATED,
            data: { id },
        })));
        return JSON.parse(JSON.stringify(productCollections));
    }
    async updateCollections(data, sharedContext = {}) {
        const productCollections = await this.productCollectionService_.update(data, sharedContext);
        await this.eventBusModuleService_?.emit(productCollections.map(({ id }) => ({
            eventName: product_collection_1.ProductCollectionEvents.COLLECTION_UPDATED,
            data: { id },
        })));
        return JSON.parse(JSON.stringify(productCollections));
    }
    async deleteCollections(productCollectionIds, sharedContext = {}) {
        await this.productCollectionService_.delete(productCollectionIds, sharedContext);
        await this.eventBusModuleService_?.emit(productCollectionIds.map((id) => ({
            eventName: product_collection_1.ProductCollectionEvents.COLLECTION_DELETED,
            data: { id },
        })));
    }
    async retrieveCategory(productCategoryId, config = {}, sharedContext = {}) {
        const productCategory = await this.productCategoryService_.retrieve(productCategoryId, config, sharedContext);
        return JSON.parse(JSON.stringify(productCategory));
    }
    async listCategories(filters = {}, config = {}, sharedContext = {}) {
        const categories = await this.productCategoryService_.list(filters, config, sharedContext);
        return JSON.parse(JSON.stringify(categories));
    }
    async createCategory(data, sharedContext = {}) {
        const productCategory = await this.productCategoryService_.create(data, sharedContext);
        await this.eventBusModuleService_?.emit(product_category_1.ProductCategoryEvents.CATEGORY_CREATED, { id: productCategory.id });
        return JSON.parse(JSON.stringify(productCategory));
    }
    async updateCategory(categoryId, data, sharedContext = {}) {
        const productCategory = await this.productCategoryService_.update(categoryId, data, sharedContext);
        await this.eventBusModuleService_?.emit(product_category_1.ProductCategoryEvents.CATEGORY_UPDATED, { id: productCategory.id });
        return JSON.parse(JSON.stringify(productCategory));
    }
    async deleteCategory(categoryId, sharedContext = {}) {
        await this.productCategoryService_.delete(categoryId, sharedContext);
        await this.eventBusModuleService_?.emit(product_category_1.ProductCategoryEvents.CATEGORY_DELETED, { id: categoryId });
    }
    async listAndCountCategories(filters = {}, config = {}, sharedContext = {}) {
        const categories = await this.productCategoryService_.listAndCount(filters, config, sharedContext);
        return JSON.parse(JSON.stringify(categories));
    }
    async create(data, sharedContext) {
        const products = await this.create_(data, sharedContext);
        const createdProducts = await this.baseRepository_.serialize(products, {
            populate: true,
        });
        await this.eventBusModuleService_?.emit(createdProducts.map(({ id }) => ({
            eventName: product_1.ProductEvents.PRODUCT_CREATED,
            data: { id },
        })));
        return createdProducts;
    }
    async update(data, sharedContext = {}) {
        const products = await this.update_(data, sharedContext);
        const updatedProducts = await this.baseRepository_.serialize(products, {
            populate: true,
        });
        await this.eventBusModuleService_?.emit(updatedProducts.map(({ id }) => ({
            eventName: product_1.ProductEvents.PRODUCT_UPDATED,
            data: { id },
        })));
        return updatedProducts;
    }
    async create_(data, sharedContext = {}) {
        const productVariantsMap = new Map();
        const productOptionsMap = new Map();
        const productsData = await (0, utils_1.promiseAll)(data.map(async (product) => {
            const productData = { ...product };
            if (!productData.handle) {
                productData.handle = (0, utils_1.kebabCase)(product.title);
            }
            const variants = productData.variants;
            const options = productData.options;
            delete productData.options;
            delete productData.variants;
            productVariantsMap.set(productData.handle, variants ?? []);
            productOptionsMap.set(productData.handle, options ?? []);
            if (productData.is_giftcard) {
                productData.discountable = false;
            }
            await this.upsertAndAssignImagesToProductData(productData, sharedContext);
            await this.upsertAndAssignProductTagsToProductData(productData, sharedContext);
            await this.upsertAndAssignProductTypeToProductData(productData, sharedContext);
            return productData;
        }));
        const products = await this.productService_.create(productsData, sharedContext);
        const productByHandleMap = new Map(products.map((product) => [product.handle, product]));
        const productOptionsData = [...productOptionsMap]
            .map(([handle, options]) => {
            return options.map((option) => {
                const productOptionsData = {
                    ...option,
                };
                const product = productByHandleMap.get(handle);
                const productId = product?.id;
                if (productId) {
                    productOptionsData.product_id = productId;
                }
                else if (product) {
                    productOptionsData.product = product;
                }
                return productOptionsData;
            });
        })
            .flat();
        const productOptions = await this.productOptionService_.create(productOptionsData, sharedContext);
        for (const variants of productVariantsMap.values()) {
            variants.forEach((variant) => {
                variant.options = variant.options?.map((option, index) => {
                    const productOption = productOptions[index];
                    return {
                        option: productOption,
                        value: option.value,
                    };
                });
            });
        }
        await (0, utils_1.promiseAll)([...productVariantsMap].map(async ([handle, variants]) => {
            return await this.productVariantService_.create(productByHandleMap.get(handle), variants, sharedContext);
        }));
        return products;
    }
    async update_(data, sharedContext = {}) {
        const productIds = data.map((pd) => pd.id);
        const existingProductVariants = await this.productVariantService_.list({ product_id: productIds }, {}, sharedContext);
        const existingProductVariantsMap = new Map(data.map((productData) => {
            const productVariantsForProduct = existingProductVariants.filter((variant) => variant.product_id === productData.id);
            return [productData.id, productVariantsForProduct];
        }));
        const productVariantsMap = new Map();
        const productOptionsMap = new Map();
        const productsData = await (0, utils_1.promiseAll)(data.map(async (product) => {
            const { variants, ...productData } = product;
            if (!(0, utils_1.isDefined)(productData.id)) {
                throw new utils_1.MedusaError(utils_1.MedusaError.Types.NOT_FOUND, `Cannot update product without id`);
            }
            productVariantsMap.set(productData.id, variants ?? []);
            if (productData.is_giftcard) {
                productData.discountable = false;
            }
            await this.upsertAndAssignImagesToProductData(productData, sharedContext);
            await this.upsertAndAssignProductTagsToProductData(productData, sharedContext);
            await this.upsertAndAssignProductTypeToProductData(productData, sharedContext);
            await this.upsertAndAssignOptionsToProductData(productData, sharedContext);
            productOptionsMap.set(productData.id, (productData.options ?? []));
            return productData;
        }));
        const products = await this.productService_.update(productsData, sharedContext);
        const productByIdMap = new Map(products.map((product) => [product.id, product]));
        const productVariantIdsToDelete = [];
        const productVariantsToCreateMap = new Map();
        const productVariantsToUpdateMap = new Map();
        for (const [productId, variants] of productVariantsMap) {
            const variantsToCreate = [];
            const variantsToUpdate = [];
            const existingVariants = existingProductVariantsMap.get(productId);
            const productOptions = productOptionsMap.get(productId);
            variants.forEach((variant) => {
                const isVariantIdDefined = "id" in variant && (0, utils_1.isDefined)(variant.id);
                if (isVariantIdDefined) {
                    variantsToUpdate.push(variant);
                }
                else {
                    variantsToCreate.push(variant);
                }
                const variantOptions = variant.options?.map((option, index) => {
                    const productOption = productOptions[index];
                    return {
                        option: productOption,
                        value: option.value,
                    };
                });
                if (variantOptions?.length) {
                    variant.options = variantOptions;
                }
            });
            productVariantsToCreateMap.set(productId, variantsToCreate);
            productVariantsToUpdateMap.set(productId, variantsToUpdate);
            const variantsToUpdateIds = variantsToUpdate.map((v) => v?.id);
            const existingVariantIds = existingVariants?.map((v) => v.id) || [];
            const variantsToUpdateSet = new Set(variantsToUpdateIds);
            productVariantIdsToDelete.push(...new Set(existingVariantIds.filter((x) => !variantsToUpdateSet.has(x))));
        }
        const promises = [];
        productVariantsToCreateMap.forEach((variants, productId) => {
            promises.push(this.productVariantService_.create(productByIdMap.get(productId), variants, sharedContext));
        });
        productVariantsToUpdateMap.forEach((variants, productId) => {
            promises.push(this.productVariantService_.update(productByIdMap.get(productId), variants, sharedContext));
        });
        if (productVariantIdsToDelete.length) {
            promises.push(this.productVariantService_.softDelete(productVariantIdsToDelete, sharedContext));
        }
        await (0, utils_1.promiseAll)(promises);
        return products;
    }
    async upsertAndAssignOptionsToProductData(productData, sharedContext = {}) {
        if (productData.options?.length) {
            productData.options = await this.productOptionService_.upsert(productData.options, sharedContext);
        }
    }
    async upsertAndAssignImagesToProductData(productData, sharedContext = {}) {
        if (!productData.thumbnail && productData.images?.length) {
            productData.thumbnail = (0, utils_1.isString)(productData.images[0])
                ? productData.images[0]
                : productData.images[0].url;
        }
        if (productData.images?.length) {
            productData.images = await this.productImageService_.upsert(productData.images.map((image) => {
                if ((0, utils_1.isString)(image)) {
                    return image;
                }
                else {
                    return image.url;
                }
            }), sharedContext);
        }
    }
    async upsertAndAssignProductTagsToProductData(productData, sharedContext = {}) {
        if (productData.tags?.length) {
            productData.tags = await this.productTagService_.upsert(productData.tags, sharedContext);
        }
    }
    async upsertAndAssignProductTypeToProductData(productData, sharedContext = {}) {
        if ((0, utils_1.isDefined)(productData.type)) {
            const productType = await this.productTypeService_.upsert([productData.type], sharedContext);
            productData.type = productType?.[0];
        }
    }
    async delete(productIds, sharedContext = {}) {
        await this.productService_.delete(productIds, sharedContext);
        await this.eventBusModuleService_?.emit(productIds.map((id) => ({
            eventName: product_1.ProductEvents.PRODUCT_DELETED,
            data: { id },
        })));
    }
    async softDelete(productIds, { returnLinkableKeys } = {}, sharedContext = {}) {
        const [products, cascadedEntitiesMap] = await this.softDelete_(productIds, sharedContext);
        const softDeletedProducts = await this.baseRepository_.serialize(products, {
            populate: true,
        });
        await this.eventBusModuleService_?.emit(softDeletedProducts.map(({ id }) => ({
            eventName: product_1.ProductEvents.PRODUCT_DELETED,
            data: { id },
        })));
        let mappedCascadedEntitiesMap;
        if (returnLinkableKeys) {
            // Map internal table/column names to their respective external linkable keys
            // eg: product.id = product_id, variant.id = variant_id
            mappedCascadedEntitiesMap = (0, utils_1.mapObjectTo)(cascadedEntitiesMap, joiner_config_1.entityNameToLinkableKeysMap, {
                pick: returnLinkableKeys,
            });
        }
        return mappedCascadedEntitiesMap ? mappedCascadedEntitiesMap : void 0;
    }
    async softDelete_(productIds, sharedContext = {}) {
        return await this.productService_.softDelete(productIds, sharedContext);
    }
    async restore(productIds, { returnLinkableKeys } = {}, sharedContext = {}) {
        const [_, cascadedEntitiesMap] = await this.restore_(productIds, sharedContext);
        let mappedCascadedEntitiesMap;
        if (returnLinkableKeys) {
            // Map internal table/column names to their respective external linkable keys
            // eg: product.id = product_id, variant.id = variant_id
            mappedCascadedEntitiesMap = (0, utils_1.mapObjectTo)(cascadedEntitiesMap, joiner_config_1.entityNameToLinkableKeysMap, {
                pick: returnLinkableKeys,
            });
        }
        return mappedCascadedEntitiesMap ? mappedCascadedEntitiesMap : void 0;
    }
    async restoreVariants(variantIds, { returnLinkableKeys } = {}, sharedContext = {}) {
        const [_, cascadedEntitiesMap] = await this.productVariantService_.restore(variantIds, sharedContext);
        let mappedCascadedEntitiesMap;
        if (returnLinkableKeys) {
            mappedCascadedEntitiesMap = (0, utils_1.mapObjectTo)(cascadedEntitiesMap, joiner_config_1.entityNameToLinkableKeysMap, {
                pick: returnLinkableKeys,
            });
        }
        return mappedCascadedEntitiesMap ? mappedCascadedEntitiesMap : void 0;
    }
    async restore_(productIds, sharedContext = {}) {
        return await this.productService_.restore(productIds, sharedContext);
    }
}
exports.default = ProductModuleService;
__decorate([
    (0, utils_1.InjectManager)("baseRepository_"),
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "list", null);
__decorate([
    (0, utils_1.InjectManager)("baseRepository_"),
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "retrieve", null);
__decorate([
    (0, utils_1.InjectManager)("baseRepository_"),
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "listAndCount", null);
__decorate([
    (0, utils_1.InjectManager)("baseRepository_"),
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "retrieveVariant", null);
__decorate([
    (0, utils_1.InjectManager)("baseRepository_"),
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "listVariants", null);
__decorate([
    (0, utils_1.InjectManager)("baseRepository_"),
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "listAndCountVariants", null);
__decorate([
    (0, utils_1.InjectManager)("baseRepository_"),
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "retrieveTag", null);
__decorate([
    (0, utils_1.InjectManager)("baseRepository_"),
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "listTags", null);
__decorate([
    (0, utils_1.InjectManager)("baseRepository_"),
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "listAndCountTags", null);
__decorate([
    (0, utils_1.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "createTags", null);
__decorate([
    (0, utils_1.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "updateTags", null);
__decorate([
    (0, utils_1.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "deleteTags", null);
__decorate([
    (0, utils_1.InjectManager)("baseRepository_"),
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "retrieveType", null);
__decorate([
    (0, utils_1.InjectManager)("baseRepository_"),
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "listTypes", null);
__decorate([
    (0, utils_1.InjectManager)("baseRepository_"),
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "listAndCountTypes", null);
__decorate([
    (0, utils_1.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "createTypes", null);
__decorate([
    (0, utils_1.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "updateTypes", null);
__decorate([
    (0, utils_1.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "deleteTypes", null);
__decorate([
    (0, utils_1.InjectManager)("baseRepository_"),
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "retrieveOption", null);
__decorate([
    (0, utils_1.InjectManager)("baseRepository_"),
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "listOptions", null);
__decorate([
    (0, utils_1.InjectManager)("baseRepository_"),
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "listAndCountOptions", null);
__decorate([
    (0, utils_1.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "createOptions", null);
__decorate([
    (0, utils_1.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "updateOptions", null);
__decorate([
    (0, utils_1.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "deleteOptions", null);
__decorate([
    (0, utils_1.InjectManager)("baseRepository_"),
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "retrieveCollection", null);
__decorate([
    (0, utils_1.InjectManager)("baseRepository_"),
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "listCollections", null);
__decorate([
    (0, utils_1.InjectManager)("baseRepository_"),
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "listAndCountCollections", null);
__decorate([
    (0, utils_1.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "createCollections", null);
__decorate([
    (0, utils_1.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "updateCollections", null);
__decorate([
    (0, utils_1.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "deleteCollections", null);
__decorate([
    (0, utils_1.InjectManager)("baseRepository_"),
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "retrieveCategory", null);
__decorate([
    (0, utils_1.InjectManager)("baseRepository_"),
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "listCategories", null);
__decorate([
    (0, utils_1.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "createCategory", null);
__decorate([
    (0, utils_1.InjectTransactionManager)("baseRepository_"),
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "updateCategory", null);
__decorate([
    (0, utils_1.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "deleteCategory", null);
__decorate([
    (0, utils_1.InjectManager)("baseRepository_"),
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "listAndCountCategories", null);
__decorate([
    (0, utils_1.InjectManager)("baseRepository_"),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "create", null);
__decorate([
    (0, utils_1.InjectManager)("baseRepository_"),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "update", null);
__decorate([
    (0, utils_1.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "create_", null);
__decorate([
    (0, utils_1.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "update_", null);
__decorate([
    (0, utils_1.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "delete", null);
__decorate([
    (0, utils_1.InjectManager)("baseRepository_"),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "softDelete", null);
__decorate([
    (0, utils_1.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "softDelete_", null);
__decorate([
    (0, utils_1.InjectManager)("baseRepository_"),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "restore", null);
__decorate([
    (0, utils_1.InjectTransactionManager)("baseRepository_"),
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "restoreVariants", null);
__decorate([
    (0, utils_1.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], ProductModuleService.prototype, "restore_", null);
