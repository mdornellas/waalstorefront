"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PriceListRuleRepository = void 0;
const utils_1 = require("@medusajs/utils");
const core_1 = require("@mikro-orm/core");
const _models_1 = require("../models");
class PriceListRuleRepository extends utils_1.DALUtils.MikroOrmBaseRepository {
    constructor({ manager }) {
        // @ts-ignore
        // eslint-disable-next-line prefer-rest-params
        super(...arguments);
        this.manager_ = manager;
    }
    async find(findOptions = { where: {} }, context = {}) {
        const manager = this.getActiveManager(context);
        const findOptions_ = { ...findOptions };
        findOptions_.options ?? (findOptions_.options = {});
        Object.assign(findOptions_.options, {
            strategy: core_1.LoadStrategy.SELECT_IN,
        });
        return await manager.find(_models_1.PriceListRule, findOptions_.where, findOptions_.options);
    }
    async findAndCount(findOptions = { where: {} }, context = {}) {
        const manager = this.getActiveManager(context);
        const findOptions_ = { ...findOptions };
        findOptions_.options ?? (findOptions_.options = {});
        Object.assign(findOptions_.options, {
            strategy: core_1.LoadStrategy.SELECT_IN,
        });
        return await manager.findAndCount(_models_1.PriceListRule, findOptions_.where, findOptions_.options);
    }
    async delete(ids, context = {}) {
        const manager = this.getActiveManager(context);
        await manager.nativeDelete(_models_1.PriceListRule, { id: { $in: ids } }, {});
    }
    async create(data, context = {}) {
        const manager = this.getActiveManager(context);
        const priceListRule = data.map((priceListRule) => {
            const { price_list_id: priceListId, rule_type_id: ruleTypeId, ...createData } = priceListRule;
            if (priceListId) {
                createData.price_list = priceListId;
            }
            if (ruleTypeId) {
                createData.rule_type = ruleTypeId;
            }
            return manager.create(_models_1.PriceListRule, createData);
        });
        manager.persist(priceListRule);
        return priceListRule;
    }
    async update(data, context = {}) {
        const manager = this.getActiveManager(context);
        const priceListIds = data.map((priceListRule) => priceListRule.id);
        const existingPriceListRules = await this.find({
            where: {
                id: {
                    $in: priceListIds,
                },
            },
        }, context);
        const dataAndExistingIdDifference = (0, utils_1.arrayDifference)(data.map((d) => d.id), existingPriceListRules.map((plr) => plr.id));
        if (dataAndExistingIdDifference.length) {
            throw new utils_1.MedusaError(utils_1.MedusaError.Types.NOT_FOUND, `PriceListRule with id(s) "${dataAndExistingIdDifference.join(", ")}" not found`);
        }
        const existingPriceListRuleMap = new Map(existingPriceListRules.map((priceList) => [
            priceList.id,
            priceList,
        ]));
        const priceListRules = data.map((priceListRule) => {
            const { price_list_id, rule_type_id, ...priceListRuleData } = priceListRule;
            const existingPriceListRule = existingPriceListRuleMap.get(priceListRule.id);
            if (price_list_id) {
                priceListRuleData.price_list = price_list_id;
            }
            if (rule_type_id) {
                priceListRuleData.rule_type = rule_type_id;
            }
            return manager.assign(existingPriceListRule, priceListRuleData);
        });
        manager.persist(priceListRules);
        return priceListRules;
    }
}
exports.PriceListRuleRepository = PriceListRuleRepository;
