"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PriceListRuleValueRepository = void 0;
const utils_1 = require("@medusajs/utils");
const core_1 = require("@mikro-orm/core");
const _models_1 = require("../models");
class PriceListRuleValueRepository extends utils_1.DALUtils.MikroOrmBaseRepository {
    constructor({ manager }) {
        // @ts-ignore
        // eslint-disable-next-line prefer-rest-params
        super(...arguments);
        this.manager_ = manager;
    }
    async find(findOptions = { where: {} }, context = {}) {
        const manager = this.getActiveManager(context);
        const findOptions_ = { ...findOptions };
        findOptions_.options ?? (findOptions_.options = {});
        Object.assign(findOptions_.options, {
            strategy: core_1.LoadStrategy.SELECT_IN,
        });
        return await manager.find(_models_1.PriceListRuleValue, findOptions_.where, findOptions_.options);
    }
    async findAndCount(findOptions = { where: {} }, context = {}) {
        const manager = this.getActiveManager(context);
        const findOptions_ = { ...findOptions };
        findOptions_.options ?? (findOptions_.options = {});
        Object.assign(findOptions_.options, {
            strategy: core_1.LoadStrategy.SELECT_IN,
        });
        return await manager.findAndCount(_models_1.PriceListRuleValue, findOptions_.where, findOptions_.options);
    }
    async delete(ids, context = {}) {
        const manager = this.getActiveManager(context);
        await manager.nativeDelete(_models_1.PriceListRuleValue, { id: { $in: ids } }, {});
    }
    async create(data, context = {}) {
        const manager = this.getActiveManager(context);
        const priceListRuleValues = data.map((priceRuleValueData) => {
            const { price_list_rule_id: priceListRuleId, ...priceRuleValue } = priceRuleValueData;
            if (priceListRuleId) {
                priceRuleValue.price_list_rule = priceListRuleId;
            }
            return manager.create(_models_1.PriceListRuleValue, priceRuleValue);
        });
        manager.persist(priceListRuleValues);
        return priceListRuleValues;
    }
    async update(data, context = {}) {
        const manager = this.getActiveManager(context);
        const priceValueIds = data.map((priceRuleValueData) => priceRuleValueData.id);
        const existingPriceValues = await this.find({
            where: {
                id: {
                    $in: priceValueIds,
                },
            },
        }, context);
        const dataAndExistingIdDifference = (0, utils_1.arrayDifference)(data.map((d) => d.id), existingPriceValues.map((pv) => pv.id));
        if (dataAndExistingIdDifference.length) {
            throw new utils_1.MedusaError(utils_1.MedusaError.Types.NOT_FOUND, `PriceListRuleValue with id(s) "${dataAndExistingIdDifference.join(", ")}" not found`);
        }
        const existingValuesMap = new Map(existingPriceValues.map((priceValue) => [
            priceValue.id,
            priceValue,
        ]));
        const priceValues = data.map((priceRuleValueData) => {
            const existingPriceValue = existingValuesMap.get(priceRuleValueData.id);
            return manager.assign(existingPriceValue, priceRuleValueData);
        });
        manager.persist(priceValues);
        return priceValues;
    }
}
exports.PriceListRuleValueRepository = PriceListRuleValueRepository;
