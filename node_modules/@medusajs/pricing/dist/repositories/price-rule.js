"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PriceRuleRepository = void 0;
const utils_1 = require("@medusajs/utils");
const core_1 = require("@mikro-orm/core");
const _models_1 = require("../models");
class PriceRuleRepository extends utils_1.DALUtils.MikroOrmBaseRepository {
    constructor({ manager }) {
        // @ts-ignore
        // eslint-disable-next-line prefer-rest-params
        super(...arguments);
        this.manager_ = manager;
    }
    async find(findOptions = { where: {} }, context = {}) {
        const manager = this.getActiveManager(context);
        const findOptions_ = { ...findOptions };
        findOptions_.options ?? (findOptions_.options = {});
        Object.assign(findOptions_.options, {
            strategy: core_1.LoadStrategy.SELECT_IN,
        });
        return await manager.find(_models_1.PriceRule, findOptions_.where, findOptions_.options);
    }
    async findAndCount(findOptions = { where: {} }, context = {}) {
        const manager = this.getActiveManager(context);
        const findOptions_ = { ...findOptions };
        findOptions_.options ?? (findOptions_.options = {});
        Object.assign(findOptions_.options, {
            strategy: core_1.LoadStrategy.SELECT_IN,
        });
        return await manager.findAndCount(_models_1.PriceRule, findOptions_.where, findOptions_.options);
    }
    async delete(ids, context = {}) {
        const manager = this.getActiveManager(context);
        await manager.nativeDelete(_models_1.PriceRule, { id: { $in: ids } }, {});
    }
    async create(data, context = {}) {
        const manager = this.getActiveManager(context);
        const toCreate = data.map((ruleData) => {
            const ruleDataClone = { ...ruleData };
            ruleDataClone.rule_type ?? (ruleDataClone.rule_type = ruleData.rule_type_id);
            ruleDataClone.price_set ?? (ruleDataClone.price_set = ruleData.price_set_id);
            ruleDataClone.price_set_money_amount ?? (ruleDataClone.price_set_money_amount = ruleData.price_set_money_amount_id);
            return ruleDataClone;
        });
        const priceRules = toCreate.map((ruleData) => {
            return manager.create(_models_1.PriceRule, ruleData);
        });
        manager.persist(priceRules);
        return priceRules;
    }
    async update(data, context = {}) {
        const manager = this.getActiveManager(context);
        const priceRuleIds = data.map((priceRuleData) => priceRuleData.id);
        const existingPriceRules = await this.find({
            where: {
                id: {
                    $in: priceRuleIds,
                },
            },
        }, context);
        const existingPriceRulesMap = new Map(existingPriceRules.map((priceRule) => [
            priceRule.id,
            priceRule,
        ]));
        const priceRules = data.map((priceRuleData) => {
            const existingPriceRule = existingPriceRulesMap.get(priceRuleData.id);
            if (!existingPriceRule) {
                throw new utils_1.MedusaError(utils_1.MedusaError.Types.NOT_FOUND, `PriceRule with id "${priceRuleData.id}" not found`);
            }
            return manager.assign(existingPriceRule, priceRuleData);
        });
        manager.persist(priceRules);
        return priceRules;
    }
}
exports.PriceRuleRepository = PriceRuleRepository;
