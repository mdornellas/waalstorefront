"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@medusajs/types");
const utils_1 = require("@medusajs/utils");
const utils_2 = require("@medusajs/utils");
const joiner_config_1 = require("../joiner-config");
class PricingModuleService {
    constructor({ baseRepository, pricingRepository, moneyAmountService, currencyService, ruleTypeService, priceSetService, priceSetMoneyAmountRulesService, priceRuleService, priceSetRuleTypeService, priceSetMoneyAmountService, priceListService, priceListRuleService, priceListRuleValueService, }, moduleDeclaration) {
        this.moduleDeclaration = moduleDeclaration;
        this.baseRepository_ = baseRepository;
        this.pricingRepository_ = pricingRepository;
        this.currencyService_ = currencyService;
        this.moneyAmountService_ = moneyAmountService;
        this.ruleTypeService_ = ruleTypeService;
        this.priceSetService_ = priceSetService;
        this.priceSetMoneyAmountRulesService_ = priceSetMoneyAmountRulesService;
        this.ruleTypeService_ = ruleTypeService;
        this.priceRuleService_ = priceRuleService;
        this.priceSetRuleTypeService_ = priceSetRuleTypeService;
        this.priceSetMoneyAmountService_ = priceSetMoneyAmountService;
        this.priceListService_ = priceListService;
        this.priceListRuleService_ = priceListRuleService;
        this.priceListRuleValueService_ = priceListRuleValueService;
    }
    __joinerConfig() {
        return joiner_config_1.joinerConfig;
    }
    async calculatePrices(pricingFilters, pricingContext = { context: {} }, sharedContext = {}) {
        const results = await this.pricingRepository_.calculatePrices(pricingFilters, pricingContext, sharedContext);
        const pricesSetPricesMap = (0, utils_2.groupBy)(results, "price_set_id");
        const calculatedPrices = pricingFilters.id.map((priceSetId) => {
            // This is where we select prices, for now we just do a first match based on the database results
            // which is prioritized by number_rules first for exact match and then deafult_priority of the rule_type
            // inject custom price selection here
            const prices = pricesSetPricesMap.get(priceSetId) || [];
            const priceListPrice = prices?.find((p) => !!p.price_list_id);
            const defaultPrice = prices?.find((p) => !!!p.price_list_id);
            let calculatedPrice = defaultPrice;
            let originalPrice = defaultPrice;
            if (priceListPrice) {
                calculatedPrice = priceListPrice;
                if (priceListPrice.price_list_type === utils_1.PriceListType.OVERRIDE) {
                    originalPrice = priceListPrice;
                }
            }
            return {
                id: priceSetId,
                is_calculated_price_price_list: !!calculatedPrice?.price_list_id,
                calculated_amount: parseInt(calculatedPrice?.amount || "") || null,
                is_original_price_price_list: !!originalPrice?.price_list_id,
                original_amount: parseInt(originalPrice?.amount || "") || null,
                currency_code: calculatedPrice?.currency_code || null,
                calculated_price: {
                    money_amount_id: calculatedPrice?.id || null,
                    price_list_id: calculatedPrice?.price_list_id || null,
                    price_list_type: calculatedPrice?.price_list_type || null,
                    min_quantity: parseInt(calculatedPrice?.min_quantity || "") || null,
                    max_quantity: parseInt(calculatedPrice?.max_quantity || "") || null,
                },
                original_price: {
                    money_amount_id: originalPrice?.id || null,
                    price_list_id: originalPrice?.price_list_id || null,
                    price_list_type: originalPrice?.price_list_type || null,
                    min_quantity: parseInt(originalPrice?.min_quantity || "") || null,
                    max_quantity: parseInt(originalPrice?.max_quantity || "") || null,
                },
            };
        });
        return JSON.parse(JSON.stringify(calculatedPrices));
    }
    async retrieve(id, config = {}, sharedContext = {}) {
        const priceSet = await this.priceSetService_.retrieve(id, config, sharedContext);
        return this.baseRepository_.serialize(priceSet, {
            populate: true,
        });
    }
    async list(filters = {}, config = {}, sharedContext = {}) {
        const priceSets = await this.priceSetService_.list(filters, config, sharedContext);
        return this.baseRepository_.serialize(priceSets, {
            populate: true,
        });
    }
    async listAndCount(filters = {}, config = {}, sharedContext = {}) {
        const [priceSets, count] = await this.priceSetService_.listAndCount(filters, config, sharedContext);
        return [
            await this.baseRepository_.serialize(priceSets, {
                populate: true,
            }),
            count,
        ];
    }
    async create(data, sharedContext = {}) {
        const input = Array.isArray(data) ? data : [data];
        const priceSets = await this.create_(input, sharedContext);
        const dbPriceSets = await this.list({ id: priceSets.filter((p) => !!p).map((p) => p.id) }, {
            relations: ["rule_types", "money_amounts", "price_rules"],
        }, sharedContext);
        return (Array.isArray(data) ? dbPriceSets : dbPriceSets[0]);
    }
    async create_(data, sharedContext = {}) {
        const ruleAttributes = data
            .map((d) => d.rules?.map((r) => r.rule_attribute) ?? [])
            .flat();
        const ruleTypes = await this.ruleTypeService_.list({
            rule_attribute: ruleAttributes,
        }, {}, sharedContext);
        const ruleTypeMap = ruleTypes.reduce((acc, curr) => {
            acc.set(curr.rule_attribute, curr);
            return acc;
        }, new Map());
        const invalidRuleAttributes = ruleAttributes.filter((r) => !ruleTypeMap.has(r));
        if (invalidRuleAttributes.length > 0) {
            throw new utils_2.MedusaError(utils_2.MedusaError.Types.NOT_FOUND, `Rule types don't exist for: ${invalidRuleAttributes.join(", ")}`);
        }
        const invalidMoneyAmountRule = data
            .map((d) => d.prices?.map((ma) => Object.keys(ma.rules)).flat() ?? [])
            .flat()
            .filter((r) => !ruleTypeMap.has(r));
        if (invalidMoneyAmountRule.length > 0) {
            throw new utils_2.MedusaError(utils_2.MedusaError.Types.INVALID_DATA, `Rule types don't exist for money amounts with rule attribute: ${invalidMoneyAmountRule.join(", ")}`);
        }
        // Bulk create price sets
        const priceSetData = data.map(({ rules, prices, ...rest }) => rest);
        const createdPriceSets = await this.priceSetService_.create(priceSetData, sharedContext);
        // Price set rule types
        const ruleTypeData = data.flatMap((item, index) => item.rules?.map((rule) => ({
            rule_type: ruleTypeMap.get(rule.rule_attribute),
            price_set: createdPriceSets[index],
        })) || []);
        if (ruleTypeData.length > 0) {
            await this.priceSetRuleTypeService_.create(ruleTypeData, sharedContext);
        }
        // Money amounts
        const moneyAmountData = data.flatMap((item) => item.prices || []);
        const createdMoneyAmounts = await this.moneyAmountService_.create(moneyAmountData, sharedContext);
        let moneyAmountIndex = 0;
        const priceSetMoneyAmountData = [];
        const priceRulesData = [];
        for (const [index, item] of data.entries()) {
            for (const ma of item.prices || []) {
                const cleanRules = ma.rules ? (0, utils_2.removeNullish)(ma.rules) : {};
                const numberOfRules = Object.entries(cleanRules).length;
                const priceSetMoneyAmount = {
                    price_set: createdPriceSets[index],
                    money_amount: createdMoneyAmounts[moneyAmountIndex++],
                    title: "test",
                    number_rules: numberOfRules,
                };
                priceSetMoneyAmountData.push(priceSetMoneyAmount);
                for (const [k, v] of Object.entries(cleanRules)) {
                    priceRulesData.push({
                        price_set_money_amount: null,
                        rule_type: ruleTypeMap.get(k),
                        price_set: createdPriceSets[index],
                        value: v,
                        price_list_id: "test",
                    });
                }
            }
        }
        // Bulk create price set money amounts
        const createdPriceSetMoneyAmounts = await this.priceSetMoneyAmountService_.create(priceSetMoneyAmountData, sharedContext);
        // Update price set money amount references
        for (let i = 0, j = 0; i < priceSetMoneyAmountData.length; i++) {
            const rulesCount = priceSetMoneyAmountData[i].number_rules;
            for (let k = 0; k < rulesCount; k++, j++) {
                ;
                priceRulesData[j].price_set_money_amount =
                    createdPriceSetMoneyAmounts[i];
            }
        }
        // Price rules
        if (priceRulesData.length > 0) {
            await this.priceRuleService_.create(priceRulesData, sharedContext);
        }
        return createdPriceSets;
    }
    async addRules(data, sharedContext = {}) {
        const inputs = Array.isArray(data) ? data : [data];
        const priceSets = await this.addRules_(inputs, sharedContext);
        return (Array.isArray(data) ? priceSets : priceSets[0]);
    }
    async addRules_(inputs, sharedContext = {}) {
        const priceSets = await this.priceSetService_.list({ id: inputs.map((d) => d.priceSetId) }, { relations: ["rule_types"] }, sharedContext);
        const priceSetRuleTypeMap = new Map(priceSets.map((priceSet) => [
            priceSet.id,
            new Map([...priceSet.rule_types].map((rt) => [rt.rule_attribute, rt])),
        ]));
        const priceSetMap = new Map(priceSets.map((p) => [p.id, p]));
        const invalidPriceSetInputs = inputs.filter((d) => !priceSetMap.has(d.priceSetId));
        if (invalidPriceSetInputs.length) {
            throw new utils_2.MedusaError(utils_2.MedusaError.Types.INVALID_DATA, `PriceSets with ids: ${invalidPriceSetInputs
                .map((d) => d.priceSetId)
                .join(", ")} was not found`);
        }
        const ruleTypes = await this.ruleTypeService_.list({
            rule_attribute: inputs
                .map((d) => d.rules.map((r) => r.attribute))
                .flat(),
        }, {}, sharedContext);
        const ruleTypeMap = new Map(ruleTypes.map((rt) => [rt.rule_attribute, rt]));
        const invalidRuleAttributeInputs = inputs
            .map((d) => d.rules.map((r) => r.attribute))
            .flat()
            .filter((r) => !ruleTypeMap.has(r));
        if (invalidRuleAttributeInputs.length) {
            throw new utils_2.MedusaError(utils_2.MedusaError.Types.INVALID_DATA, `Rule types don't exist for attributes: ${[
                ...new Set(invalidRuleAttributeInputs),
            ].join(", ")}`);
        }
        const priceSetRuleTypesCreate = [];
        inputs.forEach((d) => {
            const priceSet = priceSetMap.get(d.priceSetId);
            for (const r of d.rules) {
                if (priceSetRuleTypeMap.get(d.priceSetId).has(r.attribute)) {
                    continue;
                }
                priceSetRuleTypesCreate.push({
                    rule_type: ruleTypeMap.get(r.attribute),
                    price_set: priceSet,
                });
            }
        });
        await this.priceSetRuleTypeService_.create(priceSetRuleTypesCreate, sharedContext);
        return this.baseRepository_.serialize(priceSets, {
            populate: true,
        });
    }
    async addPrices(data, sharedContext = {}) {
        const input = Array.isArray(data) ? data : [data];
        await this.addPrices_(input, sharedContext);
        return (await this.list({ id: input.map((d) => d.priceSetId) }, { relations: ["money_amounts"] }, sharedContext));
    }
    async addPrices_(input, sharedContext = {}) {
        const priceSets = await this.list({ id: input.map((d) => d.priceSetId) }, { relations: ["rule_types"] }, sharedContext);
        const priceSetMap = new Map(priceSets.map((p) => [p.id, p]));
        const ruleTypeMap = new Map(priceSets.map((priceSet) => [
            priceSet.id,
            new Map(priceSet.rule_types?.map((rt) => [rt.rule_attribute, rt]) ?? []),
        ]));
        input.forEach(({ priceSetId, prices }) => {
            const priceSet = priceSetMap.get(priceSetId);
            if (!priceSet) {
                throw new utils_2.MedusaError(utils_2.MedusaError.Types.INVALID_DATA, `Price set with id: ${priceSetId} not found`);
            }
            const ruleAttributes = prices
                .map((d) => (d.rules ? Object.keys(d.rules) : []))
                .flat();
            const invalidRuleAttributes = ruleAttributes.filter((r) => !ruleTypeMap.get(priceSetId).has(r));
            if (invalidRuleAttributes.length > 0) {
                throw new utils_2.MedusaError(utils_2.MedusaError.Types.NOT_FOUND, `Rule types don't exist for: ${invalidRuleAttributes.join(", ")}`);
            }
        });
        // Money amounts
        const moneyAmountsBulkData = input.flatMap((entry) => entry.prices);
        const createdMoneyAmounts = await this.moneyAmountService_.create(moneyAmountsBulkData, sharedContext);
        // Price set money amounts
        let maCursor = 0;
        const priceSetMoneyAmountsBulkData = input.flatMap(({ priceSetId, prices }) => prices.map(() => {
            const ma = createdMoneyAmounts[maCursor];
            const numberOfRules = Object.entries(prices[maCursor]?.rules ?? {}).length;
            maCursor++;
            return {
                price_set: priceSetId,
                money_amount: ma,
                title: "test",
                number_rules: numberOfRules,
            };
        }));
        const createdPriceSetMoneyAmounts = await this.priceSetMoneyAmountService_.create(priceSetMoneyAmountsBulkData, sharedContext);
        // Price rules
        let rulesCursor = 0;
        const priceRulesBulkData = input.flatMap(({ priceSetId, prices }) => prices.flatMap((ma) => {
            const rules = ma.rules ?? {};
            const priceSetMoneyAmount = createdPriceSetMoneyAmounts[rulesCursor];
            rulesCursor++;
            return Object.entries(rules).map(([k, v]) => ({
                price_set_money_amount: priceSetMoneyAmount,
                rule_type: ruleTypeMap.get(priceSetId).get(k),
                price_set: priceSetId,
                value: v,
                price_list_id: "test", // TODO: accept title
            }));
        }));
        if (priceRulesBulkData.length > 0) {
            await this.priceRuleService_.create(priceRulesBulkData, sharedContext);
        }
    }
    async removeRules(data, sharedContext = {}) {
        const priceSets = await this.priceSetService_.list({
            id: data.map((d) => d.id),
        }, undefined, sharedContext);
        const priceSetIds = priceSets.map((ps) => ps.id);
        const ruleTypes = await this.ruleTypeService_.list({
            rule_attribute: data.map((d) => d.rules || []).flat(),
        }, undefined, sharedContext);
        const ruleTypeIds = ruleTypes.map((rt) => rt.id);
        const priceSetRuleTypes = await this.priceSetRuleTypeService_.list({
            price_set_id: priceSetIds,
            rule_type_id: ruleTypeIds,
        }, undefined, sharedContext);
        const priceRules = await this.priceRuleService_.list({
            price_set_id: priceSetIds,
            rule_type_id: ruleTypeIds,
        }, {
            select: ["price_set_money_amount"],
        }, sharedContext);
        await this.priceSetRuleTypeService_.delete(priceSetRuleTypes.map((psrt) => psrt.id), sharedContext);
        await this.priceSetMoneyAmountService_.delete(priceRules.map((pr) => pr.price_set_money_amount.id), sharedContext);
    }
    async update(data, sharedContext = {}) {
        const priceSets = await this.priceSetService_.update(data, sharedContext);
        return this.baseRepository_.serialize(priceSets, {
            populate: true,
        });
    }
    async delete(ids, sharedContext = {}) {
        await this.priceSetService_.delete(ids, sharedContext);
    }
    async retrieveMoneyAmount(id, config = {}, sharedContext = {}) {
        const moneyAmount = await this.moneyAmountService_.retrieve(id, config, sharedContext);
        return this.baseRepository_.serialize(moneyAmount, {
            populate: true,
        });
    }
    async listMoneyAmounts(filters = {}, config = {}, sharedContext = {}) {
        const moneyAmounts = await this.moneyAmountService_.list(filters, config, sharedContext);
        return this.baseRepository_.serialize(moneyAmounts, {
            populate: true,
        });
    }
    async listAndCountMoneyAmounts(filters = {}, config = {}, sharedContext = {}) {
        const [moneyAmounts, count] = await this.moneyAmountService_.listAndCount(filters, config, sharedContext);
        return [
            await this.baseRepository_.serialize(moneyAmounts, {
                populate: true,
            }),
            count,
        ];
    }
    async createMoneyAmounts(data, sharedContext = {}) {
        const moneyAmounts = await this.moneyAmountService_.create(data, sharedContext);
        return this.baseRepository_.serialize(moneyAmounts, {
            populate: true,
        });
    }
    async updateMoneyAmounts(data, sharedContext = {}) {
        const moneyAmounts = await this.moneyAmountService_.update(data, sharedContext);
        return this.baseRepository_.serialize(moneyAmounts, {
            populate: true,
        });
    }
    async deleteMoneyAmounts(ids, sharedContext = {}) {
        await this.moneyAmountService_.delete(ids, sharedContext);
    }
    async retrieveCurrency(code, config = {}, sharedContext = {}) {
        const currency = await this.currencyService_.retrieve(code, config, sharedContext);
        return this.baseRepository_.serialize(currency, {
            populate: true,
        });
    }
    async listCurrencies(filters = {}, config = {}, sharedContext = {}) {
        const currencies = await this.currencyService_.list(filters, config, sharedContext);
        return this.baseRepository_.serialize(currencies, {
            populate: true,
        });
    }
    async listAndCountCurrencies(filters = {}, config = {}, sharedContext = {}) {
        const [currencies, count] = await this.currencyService_.listAndCount(filters, config, sharedContext);
        return [
            await this.baseRepository_.serialize(currencies, {
                populate: true,
            }),
            count,
        ];
    }
    async createCurrencies(data, sharedContext = {}) {
        const currencies = await this.currencyService_.create(data, sharedContext);
        return this.baseRepository_.serialize(currencies, {
            populate: true,
        });
    }
    async updateCurrencies(data, sharedContext = {}) {
        const currencies = await this.currencyService_.update(data, sharedContext);
        return this.baseRepository_.serialize(currencies, {
            populate: true,
        });
    }
    async deleteCurrencies(currencyCodes, sharedContext = {}) {
        await this.currencyService_.delete(currencyCodes, sharedContext);
    }
    async retrieveRuleType(id, config = {}, sharedContext = {}) {
        const ruleType = await this.ruleTypeService_.retrieve(id, config, sharedContext);
        return this.baseRepository_.serialize(ruleType, {
            populate: true,
        });
    }
    async listRuleTypes(filters = {}, config = {}, sharedContext = {}) {
        const ruleTypes = await this.ruleTypeService_.list(filters, config, sharedContext);
        return this.baseRepository_.serialize(ruleTypes, {
            populate: true,
        });
    }
    async listAndCountRuleTypes(filters = {}, config = {}, sharedContext = {}) {
        const [ruleTypes, count] = await this.ruleTypeService_.listAndCount(filters, config, sharedContext);
        return [
            await this.baseRepository_.serialize(ruleTypes, {
                populate: true,
            }),
            count,
        ];
    }
    async createRuleTypes(data, sharedContext = {}) {
        const ruleTypes = await this.ruleTypeService_.create(data, sharedContext);
        return this.baseRepository_.serialize(ruleTypes, {
            populate: true,
        });
    }
    async updateRuleTypes(data, sharedContext = {}) {
        const ruleTypes = await this.ruleTypeService_.update(data, sharedContext);
        return this.baseRepository_.serialize(ruleTypes, {
            populate: true,
        });
    }
    async deleteRuleTypes(ruleTypeIds, sharedContext = {}) {
        await this.ruleTypeService_.delete(ruleTypeIds, sharedContext);
    }
    async retrievePriceSetMoneyAmountRules(id, config = {}, sharedContext = {}) {
        const record = await this.priceSetMoneyAmountRulesService_.retrieve(id, config, sharedContext);
        return this.baseRepository_.serialize(record, {
            populate: true,
        });
    }
    async listPriceSetMoneyAmountRules(filters = {}, config = {}, sharedContext = {}) {
        const records = await this.priceSetMoneyAmountRulesService_.list(filters, config, sharedContext);
        return this.baseRepository_.serialize(records, {
            populate: true,
        });
    }
    async listAndCountPriceSetMoneyAmountRules(filters = {}, config = {}, sharedContext = {}) {
        const [records, count] = await this.priceSetMoneyAmountRulesService_.listAndCount(filters, config, sharedContext);
        return [
            await this.baseRepository_.serialize(records, {
                populate: true,
            }),
            count,
        ];
    }
    async listPriceSetMoneyAmounts(filters = {}, config = {}, sharedContext = {}) {
        const records = await this.priceSetMoneyAmountService_.list(filters, config, sharedContext);
        return this.baseRepository_.serialize(records, {
            populate: true,
        });
    }
    async listAndCountPriceSetMoneyAmounts(filters = {}, config = {}, sharedContext = {}) {
        const [records, count] = await this.priceSetMoneyAmountService_.listAndCount(filters, config, sharedContext);
        return [
            await this.baseRepository_.serialize(records, {
                populate: true,
            }),
            count,
        ];
    }
    async createPriceSetMoneyAmountRules(data, sharedContext = {}) {
        const records = await this.priceSetMoneyAmountRulesService_.create(data, sharedContext);
        return this.baseRepository_.serialize(records, {
            populate: true,
        });
    }
    async updatePriceSetMoneyAmountRules(data, sharedContext = {}) {
        const records = await this.priceSetMoneyAmountRulesService_.update(data, sharedContext);
        return this.baseRepository_.serialize(records, {
            populate: true,
        });
    }
    async deletePriceSetMoneyAmountRules(ids, sharedContext = {}) {
        await this.priceSetMoneyAmountRulesService_.delete(ids, sharedContext);
    }
    async retrievePriceRule(id, config = {}, sharedContext = {}) {
        const priceRule = await this.priceRuleService_.retrieve(id, config, sharedContext);
        return this.baseRepository_.serialize(priceRule, {
            populate: true,
        });
    }
    async listPriceRules(filters = {}, config = {}, sharedContext = {}) {
        const priceRules = await this.priceRuleService_.list(filters, config, sharedContext);
        return this.baseRepository_.serialize(priceRules, {
            populate: true,
        });
    }
    async listAndCountPriceRules(filters = {}, config = {}, sharedContext = {}) {
        const [priceRules, count] = await this.priceRuleService_.listAndCount(filters, config, sharedContext);
        return [
            await this.baseRepository_.serialize(priceRules, {
                populate: true,
            }),
            count,
        ];
    }
    async createPriceRules(data, sharedContext = {}) {
        const priceRules = await this.priceRuleService_.create(data, sharedContext);
        return this.baseRepository_.serialize(priceRules, {
            populate: true,
        });
    }
    async updatePriceRules(data, sharedContext = {}) {
        const priceRules = await this.priceRuleService_.update(data, sharedContext);
        return this.baseRepository_.serialize(priceRules, {
            populate: true,
        });
    }
    async deletePriceRules(priceRuleIds, sharedContext = {}) {
        await this.priceRuleService_.delete(priceRuleIds, sharedContext);
    }
    async retrievePriceList(id, config = {}, sharedContext = {}) {
        const priceList = await this.priceListService_.retrieve(id, config, sharedContext);
        return this.baseRepository_.serialize(priceList, {
            populate: true,
        });
    }
    async listPriceLists(filters = {}, config = {}, sharedContext = {}) {
        const priceLists = await this.priceListService_.list(filters, config, sharedContext);
        return this.baseRepository_.serialize(priceLists, {
            populate: true,
        });
    }
    async listAndCountPriceLists(filters = {}, config = {}, sharedContext = {}) {
        const [priceLists, count] = await this.priceListService_.listAndCount(filters, config, sharedContext);
        return [
            await this.baseRepository_.serialize(priceLists, {
                populate: true,
            }),
            count,
        ];
    }
    async createPriceLists(data, sharedContext = {}) {
        const priceLists = await this.createPriceLists_(data, sharedContext);
        return this.baseRepository_.serialize(priceLists, {
            populate: true,
        });
    }
    async createPriceLists_(data, sharedContext = {}) {
        const createdPriceLists = [];
        const ruleAttributes = data
            .map((priceListData) => Object.keys(priceListData.rules || {}))
            .flat();
        const ruleTypes = await this.listRuleTypes({
            rule_attribute: ruleAttributes,
        });
        const ruleTypeMap = new Map(ruleTypes.map((rt) => [rt.rule_attribute, rt]));
        for (const priceListData of data) {
            const { rules = {}, prices = [], ...priceListOnlyData } = priceListData;
            const [createdPriceList] = (await this.priceListService_.create([
                {
                    ...priceListOnlyData,
                    number_rules: Object.keys(rules).length,
                },
            ], sharedContext));
            createdPriceLists.push(createdPriceList);
            for (const [ruleAttribute, ruleValues = []] of Object.entries(rules)) {
                // Find or create rule type
                let ruleType = ruleTypeMap.get(ruleAttribute);
                if (!ruleType) {
                    ;
                    [ruleType] = await this.createRuleTypes([
                        {
                            name: ruleAttribute,
                            rule_attribute: ruleAttribute,
                        },
                    ], sharedContext);
                    ruleTypeMap.set(ruleAttribute, ruleType);
                }
                // Create the rule
                const [priceListRule] = await this.priceListRuleService_.create([
                    {
                        price_list: createdPriceList,
                        rule_type: ruleType?.id || ruleType,
                    },
                ], sharedContext);
                // Create the values for the rule
                for (const ruleValue of ruleValues) {
                    await this.priceListRuleValueService_.create([
                        {
                            price_list_rule: priceListRule,
                            value: ruleValue,
                        },
                    ], sharedContext);
                }
            }
            for (const price of prices) {
                const { price_set_id: priceSetId, ...moneyAmountData } = price;
                const [moneyAmount] = await this.moneyAmountService_.create([moneyAmountData], sharedContext);
                await this.priceSetMoneyAmountService_.create([
                    {
                        price_set: priceSetId,
                        price_list: createdPriceList,
                        money_amount: moneyAmount,
                        title: "test",
                        number_rules: 0,
                    },
                ], sharedContext);
            }
        }
        return createdPriceLists;
    }
    async updatePriceLists(data, sharedContext = {}) {
        const priceLists = await this.updatePriceLists_(data, sharedContext);
        return this.baseRepository_.serialize(priceLists, {
            populate: true,
        });
    }
    async updatePriceLists_(data, sharedContext = {}) {
        const updatedPriceLists = [];
        const priceListIds = data.map((d) => d.id);
        const ruleAttributes = data
            .map((priceListData) => Object.keys(priceListData.rules || {}))
            .flat();
        const existingPriceLists = await this.listPriceLists({ id: priceListIds }, { relations: ["price_list_rules"] }, sharedContext);
        const priceListRuleIds = existingPriceLists
            .map((pl) => (pl.price_list_rules || []).map((plr) => plr.id))
            .flat();
        const existingPriceListRules = await this.listPriceListRules({
            id: priceListRuleIds,
        }, {}, sharedContext);
        if (existingPriceListRules.length) {
            await this.deletePriceListRules(existingPriceListRules.map((plr) => plr.id), sharedContext);
        }
        const ruleTypes = await this.listRuleTypes({
            rule_attribute: ruleAttributes,
        }, {}, sharedContext);
        const ruleTypeMap = new Map(ruleTypes.map((rt) => [rt.rule_attribute, rt]));
        for (const priceListData of data) {
            const { rules = {}, ...priceListOnlyData } = priceListData;
            const [updatedPriceList] = (await this.priceListService_.update([
                {
                    ...priceListOnlyData,
                    number_rules: Object.keys(rules).length,
                },
            ], sharedContext));
            updatedPriceLists.push(updatedPriceList);
            for (const [ruleAttribute, ruleValues = []] of Object.entries(rules)) {
                let ruleType = ruleTypeMap.get(ruleAttribute);
                if (!ruleType) {
                    ;
                    [ruleType] = await this.createRuleTypes([
                        {
                            name: ruleAttribute,
                            rule_attribute: ruleAttribute,
                        },
                    ], sharedContext);
                    ruleTypeMap.set(ruleAttribute, ruleType);
                }
                const [priceListRule] = await this.priceListRuleService_.create([
                    {
                        price_list: updatedPriceList,
                        rule_type: ruleType?.id || ruleType,
                    },
                ], sharedContext);
                for (const ruleValue of ruleValues) {
                    await this.priceListRuleValueService_.create([
                        {
                            price_list_rule: priceListRule,
                            value: ruleValue,
                        },
                    ], sharedContext);
                }
            }
        }
        return updatedPriceLists;
    }
    async deletePriceLists(priceListIds, sharedContext = {}) {
        await this.priceListService_.delete(priceListIds, sharedContext);
    }
    async retrievePriceListRule(id, config = {}, sharedContext = {}) {
        const priceList = await this.priceListRuleService_.retrieve(id, config, sharedContext);
        return this.baseRepository_.serialize(priceList, {
            populate: true,
        });
    }
    async listPriceListRules(filters = {}, config = {}, sharedContext = {}) {
        const priceLists = await this.priceListRuleService_.list(filters, config, sharedContext);
        return this.baseRepository_.serialize(priceLists, {
            populate: true,
        });
    }
    async listAndCountPriceListRules(filters = {}, config = {}, sharedContext = {}) {
        const [priceLists, count] = await this.priceListRuleService_.listAndCount(filters, config, sharedContext);
        return [
            await this.baseRepository_.serialize(priceLists, {
                populate: true,
            }),
            count,
        ];
    }
    async createPriceListRules(data, sharedContext = {}) {
        const priceLists = await this.createPriceListRules_(data, sharedContext);
        return this.baseRepository_.serialize(priceLists, {
            populate: true,
        });
    }
    async createPriceListRules_(data, sharedContext = {}) {
        return await this.priceListRuleService_.create(data, sharedContext);
    }
    async updatePriceListRules(data, sharedContext = {}) {
        const priceLists = await this.priceListRuleService_.update(data, sharedContext);
        return this.baseRepository_.serialize(priceLists, {
            populate: true,
        });
    }
    async deletePriceListRules(priceListRuleIds, sharedContext = {}) {
        await this.priceListRuleService_.delete(priceListRuleIds, sharedContext);
    }
    async addPriceListPrices(data, sharedContext = {}) {
        return await this.addPriceListPrices_(data, sharedContext);
    }
    async addPriceListPrices_(data, sharedContext = {}) {
        const priceLists = await this.listPriceLists({ id: data.map((d) => d.priceListId) }, {}, sharedContext);
        const priceListMap = new Map(priceLists.map((p) => [p.id, p]));
        for (const { priceListId, prices } of data) {
            const priceList = priceListMap.get(priceListId);
            if (!priceList) {
                throw new utils_2.MedusaError(utils_2.MedusaError.Types.INVALID_DATA, `Price list with id: ${priceListId} not found`);
            }
            await Promise.all(prices.map(async (price) => {
                const [moneyAmount] = await this.moneyAmountService_.create([price], sharedContext);
                const psma = await this.priceSetMoneyAmountService_.create([
                    {
                        price_set: price.price_set_id,
                        money_amount: moneyAmount.id,
                        title: "test",
                        price_list: priceList.id,
                    },
                ], sharedContext);
                return psma;
            }));
        }
        return priceLists;
    }
    async setPriceListRules(data, sharedContext = {}) {
        const [priceList] = await this.setPriceListRules_([data], sharedContext);
        return priceList;
    }
    async setPriceListRules_(data, sharedContext = {}) {
        const priceLists = await this.priceListService_.list({ id: data.map((d) => d.priceListId) }, { relations: ["price_list_rules", "price_list_rules.rule_type"] }, sharedContext);
        const priceListMap = new Map(priceLists.map((p) => [p.id, p]));
        const ruleTypes = await this.listRuleTypes({
            rule_attribute: data.map((d) => Object.keys(d.rules)).flat(),
        });
        const ruleTypeMap = new Map(ruleTypes.map((rt) => [rt.rule_attribute, rt]));
        const ruleIdsToUpdate = [];
        const rulesToCreate = [];
        const priceRuleValues = new Map();
        for (const { priceListId, rules } of data) {
            const priceList = priceListMap.get(priceListId);
            if (!priceList) {
                throw new utils_2.MedusaError(utils_2.MedusaError.Types.INVALID_DATA, `Price list with id: ${priceListId} not found`);
            }
            const priceListRulesMap = new Map(priceList.price_list_rules
                .getItems()
                .map((p) => [p.rule_type.rule_attribute, p]));
            const priceListRuleValues = new Map();
            await Promise.all(Object.entries(rules).map(async ([key, value]) => {
                const ruleType = ruleTypeMap.get(key);
                if (!ruleType) {
                    throw new utils_2.MedusaError(utils_2.MedusaError.Types.INVALID_DATA, `Rule type with attribute: ${key} not found`);
                }
                const rule = priceListRulesMap.get(key);
                priceListRuleValues.set(ruleType.id, Array.isArray(value) ? value : [value]);
                if (!rule) {
                    rulesToCreate.push({
                        rule_type: ruleType.id,
                        price_list: priceListId,
                    });
                }
                else {
                    ruleIdsToUpdate.push(rule.id);
                }
            }));
            priceRuleValues.set(priceListId, priceListRuleValues);
        }
        const [createdRules, priceListValuesToDelete] = await Promise.all([
            this.priceListRuleService_.create(rulesToCreate),
            this.priceListRuleValueService_.list({
                price_list_rule_id: ruleIdsToUpdate,
            }),
        ]);
        const priceListRuleValuesToCreate = [];
        for (const { id, price_list, rule_type } of createdRules) {
            const ruleValues = priceRuleValues.get(price_list.id ?? price_list);
            if (!ruleValues) {
                continue;
            }
            const values = ruleValues.get(rule_type.id ?? rule_type);
            if (!values) {
                continue;
            }
            values.forEach((v) => {
                priceListRuleValuesToCreate.push({
                    price_list_rule: id,
                    value: v,
                });
            });
        }
        await Promise.all([
            this.priceListRuleValueService_.delete(priceListValuesToDelete.map((p) => p.id)),
            this.priceListRuleValueService_.create(priceListRuleValuesToCreate),
        ]);
        return this.baseRepository_.serialize(priceLists, {
            populate: true,
        });
    }
    async removePriceListRules(data, sharedContext = {}) {
        const [priceList] = await this.removePriceListRules_([data], sharedContext);
        return priceList;
    }
    async removePriceListRules_(data, sharedContext = {}) {
        const priceLists = await this.priceListService_.list({ id: data.map((d) => d.priceListId) }, { relations: ["price_list_rules", "price_list_rules.rule_type"] }, sharedContext);
        const priceListMap = new Map(priceLists.map((p) => [p.id, p]));
        const idsToDelete = [];
        for (const { priceListId, rules } of data) {
            const priceList = priceListMap.get(priceListId);
            if (!priceList) {
                throw new utils_2.MedusaError(utils_2.MedusaError.Types.INVALID_DATA, `Price list with id: ${priceListId} not found`);
            }
            const priceListRulesMap = new Map(priceList.price_list_rules
                .getItems()
                .map((p) => [p.rule_type.rule_attribute, p]));
            await Promise.all(rules.map(async (rule_attribute) => {
                const rule = priceListRulesMap.get(rule_attribute);
                if (rule) {
                    idsToDelete.push(rule.id);
                }
            }));
        }
        await this.priceListRuleService_.delete(idsToDelete);
        return this.baseRepository_.serialize(priceLists, {
            populate: true,
        });
    }
}
exports.default = PricingModuleService;
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(2, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "calculatePrices", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(2, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "retrieve", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(2, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "list", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(2, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "listAndCount", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "create", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "create_", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "addRules", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "addRules_", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "addPrices", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "addPrices_", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "removeRules", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "update", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "delete", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(2, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "retrieveMoneyAmount", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(2, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "listMoneyAmounts", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(2, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "listAndCountMoneyAmounts", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "createMoneyAmounts", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "updateMoneyAmounts", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "deleteMoneyAmounts", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(2, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "retrieveCurrency", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(2, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "listCurrencies", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(2, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "listAndCountCurrencies", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "createCurrencies", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "updateCurrencies", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "deleteCurrencies", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(2, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "retrieveRuleType", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(2, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "listRuleTypes", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(2, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "listAndCountRuleTypes", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "createRuleTypes", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "updateRuleTypes", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "deleteRuleTypes", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(2, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "retrievePriceSetMoneyAmountRules", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(2, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "listPriceSetMoneyAmountRules", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(2, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "listAndCountPriceSetMoneyAmountRules", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(2, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "listPriceSetMoneyAmounts", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(2, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "listAndCountPriceSetMoneyAmounts", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "createPriceSetMoneyAmountRules", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "updatePriceSetMoneyAmountRules", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "deletePriceSetMoneyAmountRules", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(2, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "retrievePriceRule", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(2, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "listPriceRules", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(2, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "listAndCountPriceRules", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "createPriceRules", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "updatePriceRules", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "deletePriceRules", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(2, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "retrievePriceList", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(2, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "listPriceLists", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(2, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "listAndCountPriceLists", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "createPriceLists", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "createPriceLists_", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "updatePriceLists", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "updatePriceLists_", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "deletePriceLists", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(2, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "retrievePriceListRule", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(2, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "listPriceListRules", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(2, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "listAndCountPriceListRules", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "createPriceListRules", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "createPriceListRules_", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "updatePriceListRules", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "deletePriceListRules", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "addPriceListPrices", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "addPriceListPrices_", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "setPriceListRules", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "setPriceListRules_", null);
__decorate([
    (0, utils_2.InjectManager)("baseRepository_"),
    __param(1, (0, utils_2.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "removePriceListRules", null);
__decorate([
    (0, utils_2.InjectTransactionManager)("baseRepository_"),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], PricingModuleService.prototype, "removePriceListRules_", null);
