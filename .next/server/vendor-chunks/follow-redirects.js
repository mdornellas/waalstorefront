/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/follow-redirects";
exports.ids = ["vendor-chunks/follow-redirects"];
exports.modules = {

/***/ "(ssr)/./node_modules/follow-redirects/debug.js":
/*!************************************************!*\
  !*** ./node_modules/follow-redirects/debug.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var debug;\nmodule.exports = function() {\n    if (!debug) {\n        try {\n            /* eslint global-require: off */ debug = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\")(\"follow-redirects\");\n        } catch (error) {}\n        if (typeof debug !== \"function\") {\n            debug = function() {};\n        }\n    }\n    debug.apply(null, arguments);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZm9sbG93LXJlZGlyZWN0cy9kZWJ1Zy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJQTtBQUVKQyxPQUFPQyxPQUFPLEdBQUc7SUFDZixJQUFJLENBQUNGLE9BQU87UUFDVixJQUFJO1lBQ0YsOEJBQThCLEdBQzlCQSxRQUFRRyxtQkFBT0EsQ0FBQyxzREFBTyxFQUFFO1FBQzNCLEVBQ0EsT0FBT0MsT0FBTyxDQUFRO1FBQ3RCLElBQUksT0FBT0osVUFBVSxZQUFZO1lBQy9CQSxRQUFRLFlBQW9CO1FBQzlCO0lBQ0Y7SUFDQUEsTUFBTUssS0FBSyxDQUFDLE1BQU1DO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVkdXNhLW5leHQvLi9ub2RlX21vZHVsZXMvZm9sbG93LXJlZGlyZWN0cy9kZWJ1Zy5qcz8yNTgxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBkZWJ1ZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghZGVidWcpIHtcbiAgICB0cnkge1xuICAgICAgLyogZXNsaW50IGdsb2JhbC1yZXF1aXJlOiBvZmYgKi9cbiAgICAgIGRlYnVnID0gcmVxdWlyZShcImRlYnVnXCIpKFwiZm9sbG93LXJlZGlyZWN0c1wiKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IC8qICovIH1cbiAgICBpZiAodHlwZW9mIGRlYnVnICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGRlYnVnID0gZnVuY3Rpb24gKCkgeyAvKiAqLyB9O1xuICAgIH1cbiAgfVxuICBkZWJ1Zy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcbiJdLCJuYW1lcyI6WyJkZWJ1ZyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwiZXJyb3IiLCJhcHBseSIsImFyZ3VtZW50cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/follow-redirects/debug.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/follow-redirects/index.js":
/*!************************************************!*\
  !*** ./node_modules/follow-redirects/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var url = __webpack_require__(/*! url */ \"url\");\nvar URL = url.URL;\nvar http = __webpack_require__(/*! http */ \"http\");\nvar https = __webpack_require__(/*! https */ \"https\");\nvar Writable = (__webpack_require__(/*! stream */ \"stream\").Writable);\nvar assert = __webpack_require__(/*! assert */ \"assert\");\nvar debug = __webpack_require__(/*! ./debug */ \"(ssr)/./node_modules/follow-redirects/debug.js\");\n// Create handlers that pass events from native requests\nvar events = [\n    \"abort\",\n    \"aborted\",\n    \"connect\",\n    \"error\",\n    \"socket\",\n    \"timeout\"\n];\nvar eventHandlers = Object.create(null);\nevents.forEach(function(event) {\n    eventHandlers[event] = function(arg1, arg2, arg3) {\n        this._redirectable.emit(event, arg1, arg2, arg3);\n    };\n});\nvar InvalidUrlError = createErrorType(\"ERR_INVALID_URL\", \"Invalid URL\", TypeError);\n// Error types with codes\nvar RedirectionError = createErrorType(\"ERR_FR_REDIRECTION_FAILURE\", \"Redirected request failed\");\nvar TooManyRedirectsError = createErrorType(\"ERR_FR_TOO_MANY_REDIRECTS\", \"Maximum number of redirects exceeded\");\nvar MaxBodyLengthExceededError = createErrorType(\"ERR_FR_MAX_BODY_LENGTH_EXCEEDED\", \"Request body larger than maxBodyLength limit\");\nvar WriteAfterEndError = createErrorType(\"ERR_STREAM_WRITE_AFTER_END\", \"write after end\");\n// An HTTP(S) request that can be redirected\nfunction RedirectableRequest(options, responseCallback) {\n    // Initialize the request\n    Writable.call(this);\n    this._sanitizeOptions(options);\n    this._options = options;\n    this._ended = false;\n    this._ending = false;\n    this._redirectCount = 0;\n    this._redirects = [];\n    this._requestBodyLength = 0;\n    this._requestBodyBuffers = [];\n    // Attach a callback if passed\n    if (responseCallback) {\n        this.on(\"response\", responseCallback);\n    }\n    // React to responses of native requests\n    var self = this;\n    this._onNativeResponse = function(response) {\n        self._processResponse(response);\n    };\n    // Perform the first request\n    this._performRequest();\n}\nRedirectableRequest.prototype = Object.create(Writable.prototype);\nRedirectableRequest.prototype.abort = function() {\n    abortRequest(this._currentRequest);\n    this.emit(\"abort\");\n};\n// Writes buffered data to the current native request\nRedirectableRequest.prototype.write = function(data, encoding, callback) {\n    // Writing is not allowed if end has been called\n    if (this._ending) {\n        throw new WriteAfterEndError();\n    }\n    // Validate input and shift parameters if necessary\n    if (!isString(data) && !isBuffer(data)) {\n        throw new TypeError(\"data should be a string, Buffer or Uint8Array\");\n    }\n    if (isFunction(encoding)) {\n        callback = encoding;\n        encoding = null;\n    }\n    // Ignore empty buffers, since writing them doesn't invoke the callback\n    // https://github.com/nodejs/node/issues/22066\n    if (data.length === 0) {\n        if (callback) {\n            callback();\n        }\n        return;\n    }\n    // Only write when we don't exceed the maximum body length\n    if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {\n        this._requestBodyLength += data.length;\n        this._requestBodyBuffers.push({\n            data: data,\n            encoding: encoding\n        });\n        this._currentRequest.write(data, encoding, callback);\n    } else {\n        this.emit(\"error\", new MaxBodyLengthExceededError());\n        this.abort();\n    }\n};\n// Ends the current native request\nRedirectableRequest.prototype.end = function(data, encoding, callback) {\n    // Shift parameters if necessary\n    if (isFunction(data)) {\n        callback = data;\n        data = encoding = null;\n    } else if (isFunction(encoding)) {\n        callback = encoding;\n        encoding = null;\n    }\n    // Write data if needed and end\n    if (!data) {\n        this._ended = this._ending = true;\n        this._currentRequest.end(null, null, callback);\n    } else {\n        var self = this;\n        var currentRequest = this._currentRequest;\n        this.write(data, encoding, function() {\n            self._ended = true;\n            currentRequest.end(null, null, callback);\n        });\n        this._ending = true;\n    }\n};\n// Sets a header value on the current native request\nRedirectableRequest.prototype.setHeader = function(name, value) {\n    this._options.headers[name] = value;\n    this._currentRequest.setHeader(name, value);\n};\n// Clears a header value on the current native request\nRedirectableRequest.prototype.removeHeader = function(name) {\n    delete this._options.headers[name];\n    this._currentRequest.removeHeader(name);\n};\n// Global timeout for all underlying requests\nRedirectableRequest.prototype.setTimeout = function(msecs, callback) {\n    var self = this;\n    // Destroys the socket on timeout\n    function destroyOnTimeout(socket) {\n        socket.setTimeout(msecs);\n        socket.removeListener(\"timeout\", socket.destroy);\n        socket.addListener(\"timeout\", socket.destroy);\n    }\n    // Sets up a timer to trigger a timeout event\n    function startTimer(socket) {\n        if (self._timeout) {\n            clearTimeout(self._timeout);\n        }\n        self._timeout = setTimeout(function() {\n            self.emit(\"timeout\");\n            clearTimer();\n        }, msecs);\n        destroyOnTimeout(socket);\n    }\n    // Stops a timeout from triggering\n    function clearTimer() {\n        // Clear the timeout\n        if (self._timeout) {\n            clearTimeout(self._timeout);\n            self._timeout = null;\n        }\n        // Clean up all attached listeners\n        self.removeListener(\"abort\", clearTimer);\n        self.removeListener(\"error\", clearTimer);\n        self.removeListener(\"response\", clearTimer);\n        if (callback) {\n            self.removeListener(\"timeout\", callback);\n        }\n        if (!self.socket) {\n            self._currentRequest.removeListener(\"socket\", startTimer);\n        }\n    }\n    // Attach callback if passed\n    if (callback) {\n        this.on(\"timeout\", callback);\n    }\n    // Start the timer if or when the socket is opened\n    if (this.socket) {\n        startTimer(this.socket);\n    } else {\n        this._currentRequest.once(\"socket\", startTimer);\n    }\n    // Clean up on events\n    this.on(\"socket\", destroyOnTimeout);\n    this.on(\"abort\", clearTimer);\n    this.on(\"error\", clearTimer);\n    this.on(\"response\", clearTimer);\n    return this;\n};\n// Proxy all other public ClientRequest methods\n[\n    \"flushHeaders\",\n    \"getHeader\",\n    \"setNoDelay\",\n    \"setSocketKeepAlive\"\n].forEach(function(method) {\n    RedirectableRequest.prototype[method] = function(a, b) {\n        return this._currentRequest[method](a, b);\n    };\n});\n// Proxy all public ClientRequest properties\n[\n    \"aborted\",\n    \"connection\",\n    \"socket\"\n].forEach(function(property) {\n    Object.defineProperty(RedirectableRequest.prototype, property, {\n        get: function() {\n            return this._currentRequest[property];\n        }\n    });\n});\nRedirectableRequest.prototype._sanitizeOptions = function(options) {\n    // Ensure headers are always present\n    if (!options.headers) {\n        options.headers = {};\n    }\n    // Since http.request treats host as an alias of hostname,\n    // but the url module interprets host as hostname plus port,\n    // eliminate the host property to avoid confusion.\n    if (options.host) {\n        // Use hostname if set, because it has precedence\n        if (!options.hostname) {\n            options.hostname = options.host;\n        }\n        delete options.host;\n    }\n    // Complete the URL object when necessary\n    if (!options.pathname && options.path) {\n        var searchPos = options.path.indexOf(\"?\");\n        if (searchPos < 0) {\n            options.pathname = options.path;\n        } else {\n            options.pathname = options.path.substring(0, searchPos);\n            options.search = options.path.substring(searchPos);\n        }\n    }\n};\n// Executes the next native request (initial or redirect)\nRedirectableRequest.prototype._performRequest = function() {\n    // Load the native protocol\n    var protocol = this._options.protocol;\n    var nativeProtocol = this._options.nativeProtocols[protocol];\n    if (!nativeProtocol) {\n        this.emit(\"error\", new TypeError(\"Unsupported protocol \" + protocol));\n        return;\n    }\n    // If specified, use the agent corresponding to the protocol\n    // (HTTP and HTTPS use different types of agents)\n    if (this._options.agents) {\n        var scheme = protocol.slice(0, -1);\n        this._options.agent = this._options.agents[scheme];\n    }\n    // Create the native request and set up its event handlers\n    var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);\n    request._redirectable = this;\n    for (var event of events){\n        request.on(event, eventHandlers[event]);\n    }\n    // RFC7230§5.3.1: When making a request directly to an origin server, […]\n    // a client MUST send only the absolute path […] as the request-target.\n    this._currentUrl = /^\\//.test(this._options.path) ? url.format(this._options) : // When making a request to a proxy, […]\n    // a client MUST send the target URI in absolute-form […].\n    this._options.path;\n    // End a redirected request\n    // (The first request must be ended explicitly with RedirectableRequest#end)\n    if (this._isRedirect) {\n        // Write the request entity and end\n        var i = 0;\n        var self = this;\n        var buffers = this._requestBodyBuffers;\n        (function writeNext(error) {\n            // Only write if this request has not been redirected yet\n            /* istanbul ignore else */ if (request === self._currentRequest) {\n                // Report any write errors\n                /* istanbul ignore if */ if (error) {\n                    self.emit(\"error\", error);\n                } else if (i < buffers.length) {\n                    var buffer = buffers[i++];\n                    /* istanbul ignore else */ if (!request.finished) {\n                        request.write(buffer.data, buffer.encoding, writeNext);\n                    }\n                } else if (self._ended) {\n                    request.end();\n                }\n            }\n        })();\n    }\n};\n// Processes a response from the current native request\nRedirectableRequest.prototype._processResponse = function(response) {\n    // Store the redirected response\n    var statusCode = response.statusCode;\n    if (this._options.trackRedirects) {\n        this._redirects.push({\n            url: this._currentUrl,\n            headers: response.headers,\n            statusCode: statusCode\n        });\n    }\n    // RFC7231§6.4: The 3xx (Redirection) class of status code indicates\n    // that further action needs to be taken by the user agent in order to\n    // fulfill the request. If a Location header field is provided,\n    // the user agent MAY automatically redirect its request to the URI\n    // referenced by the Location field value,\n    // even if the specific status code is not understood.\n    // If the response is not a redirect; return it as-is\n    var location = response.headers.location;\n    if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {\n        response.responseUrl = this._currentUrl;\n        response.redirects = this._redirects;\n        this.emit(\"response\", response);\n        // Clean up\n        this._requestBodyBuffers = [];\n        return;\n    }\n    // The response is a redirect, so abort the current request\n    abortRequest(this._currentRequest);\n    // Discard the remainder of the response to avoid waiting for data\n    response.destroy();\n    // RFC7231§6.4: A client SHOULD detect and intervene\n    // in cyclical redirections (i.e., \"infinite\" redirection loops).\n    if (++this._redirectCount > this._options.maxRedirects) {\n        this.emit(\"error\", new TooManyRedirectsError());\n        return;\n    }\n    // Store the request headers if applicable\n    var requestHeaders;\n    var beforeRedirect = this._options.beforeRedirect;\n    if (beforeRedirect) {\n        requestHeaders = Object.assign({\n            // The Host header was set by nativeProtocol.request\n            Host: response.req.getHeader(\"host\")\n        }, this._options.headers);\n    }\n    // RFC7231§6.4: Automatic redirection needs to done with\n    // care for methods not known to be safe, […]\n    // RFC7231§6.4.2–3: For historical reasons, a user agent MAY change\n    // the request method from POST to GET for the subsequent request.\n    var method = this._options.method;\n    if ((statusCode === 301 || statusCode === 302) && this._options.method === \"POST\" || // RFC7231§6.4.4: The 303 (See Other) status code indicates that\n    // the server is redirecting the user agent to a different resource […]\n    // A user agent can perform a retrieval request targeting that URI\n    // (a GET or HEAD request if using HTTP) […]\n    statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {\n        this._options.method = \"GET\";\n        // Drop a possible entity and headers related to it\n        this._requestBodyBuffers = [];\n        removeMatchingHeaders(/^content-/i, this._options.headers);\n    }\n    // Drop the Host header, as the redirect might lead to a different host\n    var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);\n    // If the redirect is relative, carry over the host of the last request\n    var currentUrlParts = url.parse(this._currentUrl);\n    var currentHost = currentHostHeader || currentUrlParts.host;\n    var currentUrl = /^\\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, {\n        host: currentHost\n    }));\n    // Determine the URL of the redirection\n    var redirectUrl;\n    try {\n        redirectUrl = url.resolve(currentUrl, location);\n    } catch (cause) {\n        this.emit(\"error\", new RedirectionError({\n            cause: cause\n        }));\n        return;\n    }\n    // Create the redirected request\n    debug(\"redirecting to\", redirectUrl);\n    this._isRedirect = true;\n    var redirectUrlParts = url.parse(redirectUrl);\n    Object.assign(this._options, redirectUrlParts);\n    // Drop confidential headers when redirecting to a less secure protocol\n    // or to a different domain that is not a superdomain\n    if (redirectUrlParts.protocol !== currentUrlParts.protocol && redirectUrlParts.protocol !== \"https:\" || redirectUrlParts.host !== currentHost && !isSubdomain(redirectUrlParts.host, currentHost)) {\n        removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);\n    }\n    // Evaluate the beforeRedirect callback\n    if (isFunction(beforeRedirect)) {\n        var responseDetails = {\n            headers: response.headers,\n            statusCode: statusCode\n        };\n        var requestDetails = {\n            url: currentUrl,\n            method: method,\n            headers: requestHeaders\n        };\n        try {\n            beforeRedirect(this._options, responseDetails, requestDetails);\n        } catch (err) {\n            this.emit(\"error\", err);\n            return;\n        }\n        this._sanitizeOptions(this._options);\n    }\n    // Perform the redirected request\n    try {\n        this._performRequest();\n    } catch (cause) {\n        this.emit(\"error\", new RedirectionError({\n            cause: cause\n        }));\n    }\n};\n// Wraps the key/value object of protocols with redirect functionality\nfunction wrap(protocols) {\n    // Default settings\n    var exports = {\n        maxRedirects: 21,\n        maxBodyLength: 10 * 1024 * 1024\n    };\n    // Wrap each protocol\n    var nativeProtocols = {};\n    Object.keys(protocols).forEach(function(scheme) {\n        var protocol = scheme + \":\";\n        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];\n        var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);\n        // Executes a request, following redirects\n        function request(input, options, callback) {\n            // Parse parameters\n            if (isString(input)) {\n                var parsed;\n                try {\n                    parsed = urlToOptions(new URL(input));\n                } catch (err) {\n                    /* istanbul ignore next */ parsed = url.parse(input);\n                }\n                if (!isString(parsed.protocol)) {\n                    throw new InvalidUrlError({\n                        input\n                    });\n                }\n                input = parsed;\n            } else if (URL && input instanceof URL) {\n                input = urlToOptions(input);\n            } else {\n                callback = options;\n                options = input;\n                input = {\n                    protocol: protocol\n                };\n            }\n            if (isFunction(options)) {\n                callback = options;\n                options = null;\n            }\n            // Set defaults\n            options = Object.assign({\n                maxRedirects: exports.maxRedirects,\n                maxBodyLength: exports.maxBodyLength\n            }, input, options);\n            options.nativeProtocols = nativeProtocols;\n            if (!isString(options.host) && !isString(options.hostname)) {\n                options.hostname = \"::1\";\n            }\n            assert.equal(options.protocol, protocol, \"protocol mismatch\");\n            debug(\"options\", options);\n            return new RedirectableRequest(options, callback);\n        }\n        // Executes a GET request, following redirects\n        function get(input, options, callback) {\n            var wrappedRequest = wrappedProtocol.request(input, options, callback);\n            wrappedRequest.end();\n            return wrappedRequest;\n        }\n        // Expose the properties on the wrapped protocol\n        Object.defineProperties(wrappedProtocol, {\n            request: {\n                value: request,\n                configurable: true,\n                enumerable: true,\n                writable: true\n            },\n            get: {\n                value: get,\n                configurable: true,\n                enumerable: true,\n                writable: true\n            }\n        });\n    });\n    return exports;\n}\n/* istanbul ignore next */ function noop() {}\n// from https://github.com/nodejs/node/blob/master/lib/internal/url.js\nfunction urlToOptions(urlObject) {\n    var options = {\n        protocol: urlObject.protocol,\n        hostname: urlObject.hostname.startsWith(\"[\") ? /* istanbul ignore next */ urlObject.hostname.slice(1, -1) : urlObject.hostname,\n        hash: urlObject.hash,\n        search: urlObject.search,\n        pathname: urlObject.pathname,\n        path: urlObject.pathname + urlObject.search,\n        href: urlObject.href\n    };\n    if (urlObject.port !== \"\") {\n        options.port = Number(urlObject.port);\n    }\n    return options;\n}\nfunction removeMatchingHeaders(regex, headers) {\n    var lastValue;\n    for(var header in headers){\n        if (regex.test(header)) {\n            lastValue = headers[header];\n            delete headers[header];\n        }\n    }\n    return lastValue === null || typeof lastValue === \"undefined\" ? undefined : String(lastValue).trim();\n}\nfunction createErrorType(code, message, baseClass) {\n    // Create constructor\n    function CustomError(properties) {\n        Error.captureStackTrace(this, this.constructor);\n        Object.assign(this, properties || {});\n        this.code = code;\n        this.message = this.cause ? message + \": \" + this.cause.message : message;\n    }\n    // Attach constructor and set default properties\n    CustomError.prototype = new (baseClass || Error)();\n    CustomError.prototype.constructor = CustomError;\n    CustomError.prototype.name = \"Error [\" + code + \"]\";\n    return CustomError;\n}\nfunction abortRequest(request) {\n    for (var event of events){\n        request.removeListener(event, eventHandlers[event]);\n    }\n    request.on(\"error\", noop);\n    request.abort();\n}\nfunction isSubdomain(subdomain, domain) {\n    assert(isString(subdomain) && isString(domain));\n    var dot = subdomain.length - domain.length - 1;\n    return dot > 0 && subdomain[dot] === \".\" && subdomain.endsWith(domain);\n}\nfunction isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n}\nfunction isFunction(value) {\n    return typeof value === \"function\";\n}\nfunction isBuffer(value) {\n    return typeof value === \"object\" && \"length\" in value;\n}\n// Exports\nmodule.exports = wrap({\n    http: http,\n    https: https\n});\nmodule.exports.wrap = wrap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZm9sbG93LXJlZGlyZWN0cy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxNQUFNQyxtQkFBT0EsQ0FBQyxnQkFBSztBQUN2QixJQUFJQyxNQUFNRixJQUFJRSxHQUFHO0FBQ2pCLElBQUlDLE9BQU9GLG1CQUFPQSxDQUFDLGtCQUFNO0FBQ3pCLElBQUlHLFFBQVFILG1CQUFPQSxDQUFDLG9CQUFPO0FBQzNCLElBQUlJLFdBQVdKLHNEQUEwQjtBQUN6QyxJQUFJSyxTQUFTTCxtQkFBT0EsQ0FBQyxzQkFBUTtBQUM3QixJQUFJTSxRQUFRTixtQkFBT0EsQ0FBQywrREFBUztBQUU3Qix3REFBd0Q7QUFDeEQsSUFBSU8sU0FBUztJQUFDO0lBQVM7SUFBVztJQUFXO0lBQVM7SUFBVTtDQUFVO0FBQzFFLElBQUlDLGdCQUFnQkMsT0FBT0MsTUFBTSxDQUFDO0FBQ2xDSCxPQUFPSSxPQUFPLENBQUMsU0FBVUMsS0FBSztJQUM1QkosYUFBYSxDQUFDSSxNQUFNLEdBQUcsU0FBVUMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLElBQUk7UUFDL0MsSUFBSSxDQUFDQyxhQUFhLENBQUNDLElBQUksQ0FBQ0wsT0FBT0MsTUFBTUMsTUFBTUM7SUFDN0M7QUFDRjtBQUVBLElBQUlHLGtCQUFrQkMsZ0JBQ3BCLG1CQUNBLGVBQ0FDO0FBRUYseUJBQXlCO0FBQ3pCLElBQUlDLG1CQUFtQkYsZ0JBQ3JCLDhCQUNBO0FBRUYsSUFBSUcsd0JBQXdCSCxnQkFDMUIsNkJBQ0E7QUFFRixJQUFJSSw2QkFBNkJKLGdCQUMvQixtQ0FDQTtBQUVGLElBQUlLLHFCQUFxQkwsZ0JBQ3ZCLDhCQUNBO0FBR0YsNENBQTRDO0FBQzVDLFNBQVNNLG9CQUFvQkMsT0FBTyxFQUFFQyxnQkFBZ0I7SUFDcEQseUJBQXlCO0lBQ3pCdkIsU0FBU3dCLElBQUksQ0FBQyxJQUFJO0lBQ2xCLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUNIO0lBQ3RCLElBQUksQ0FBQ0ksUUFB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LFlBQVl1QyxTQUFTLEVBQUVDLE1BQU07SUFDcEN0SyxPQUFPOEMsU0FBU3VILGNBQWN2SCxTQUFTd0g7SUFDdkMsSUFBSUMsTUFBTUYsVUFBVXBILE1BQU0sR0FBR3FILE9BQU9ySCxNQUFNLEdBQUc7SUFDN0MsT0FBT3NILE1BQU0sS0FBS0YsU0FBUyxDQUFDRSxJQUFJLEtBQUssT0FBT0YsVUFBVUcsUUFBUSxDQUFDRjtBQUNqRTtBQUVBLFNBQVN4SCxTQUFTVSxLQUFLO0lBQ3JCLE9BQU8sT0FBT0EsVUFBVSxZQUFZQSxpQkFBaUJtRztBQUN2RDtBQUVBLFNBQVMzRyxXQUFXUSxLQUFLO0lBQ3ZCLE9BQU8sT0FBT0EsVUFBVTtBQUMxQjtBQUVBLFNBQVNULFNBQVNTLEtBQUs7SUFDckIsT0FBTyxPQUFPQSxVQUFVLFlBQWEsWUFBWUE7QUFDbkQ7QUFFQSxVQUFVO0FBQ1ZpSCxPQUFPckMsT0FBTyxHQUFHRixLQUFLO0lBQUVySSxNQUFNQTtJQUFNQyxPQUFPQTtBQUFNO0FBQ2pEMkssbUJBQW1CLEdBQUd2QyIsInNvdXJjZXMiOlsid2VicGFjazovL21lZHVzYS1uZXh0Ly4vbm9kZV9tb2R1bGVzL2ZvbGxvdy1yZWRpcmVjdHMvaW5kZXguanM/OTRiMiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdXJsID0gcmVxdWlyZShcInVybFwiKTtcbnZhciBVUkwgPSB1cmwuVVJMO1xudmFyIGh0dHAgPSByZXF1aXJlKFwiaHR0cFwiKTtcbnZhciBodHRwcyA9IHJlcXVpcmUoXCJodHRwc1wiKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoXCJzdHJlYW1cIikuV3JpdGFibGU7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoXCIuL2RlYnVnXCIpO1xuXG4vLyBDcmVhdGUgaGFuZGxlcnMgdGhhdCBwYXNzIGV2ZW50cyBmcm9tIG5hdGl2ZSByZXF1ZXN0c1xudmFyIGV2ZW50cyA9IFtcImFib3J0XCIsIFwiYWJvcnRlZFwiLCBcImNvbm5lY3RcIiwgXCJlcnJvclwiLCBcInNvY2tldFwiLCBcInRpbWVvdXRcIl07XG52YXIgZXZlbnRIYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5ldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgZXZlbnRIYW5kbGVyc1tldmVudF0gPSBmdW5jdGlvbiAoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIHRoaXMuX3JlZGlyZWN0YWJsZS5lbWl0KGV2ZW50LCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgfTtcbn0pO1xuXG52YXIgSW52YWxpZFVybEVycm9yID0gY3JlYXRlRXJyb3JUeXBlKFxuICBcIkVSUl9JTlZBTElEX1VSTFwiLFxuICBcIkludmFsaWQgVVJMXCIsXG4gIFR5cGVFcnJvclxuKTtcbi8vIEVycm9yIHR5cGVzIHdpdGggY29kZXNcbnZhciBSZWRpcmVjdGlvbkVycm9yID0gY3JlYXRlRXJyb3JUeXBlKFxuICBcIkVSUl9GUl9SRURJUkVDVElPTl9GQUlMVVJFXCIsXG4gIFwiUmVkaXJlY3RlZCByZXF1ZXN0IGZhaWxlZFwiXG4pO1xudmFyIFRvb01hbnlSZWRpcmVjdHNFcnJvciA9IGNyZWF0ZUVycm9yVHlwZShcbiAgXCJFUlJfRlJfVE9PX01BTllfUkVESVJFQ1RTXCIsXG4gIFwiTWF4aW11bSBudW1iZXIgb2YgcmVkaXJlY3RzIGV4Y2VlZGVkXCJcbik7XG52YXIgTWF4Qm9keUxlbmd0aEV4Y2VlZGVkRXJyb3IgPSBjcmVhdGVFcnJvclR5cGUoXG4gIFwiRVJSX0ZSX01BWF9CT0RZX0xFTkdUSF9FWENFRURFRFwiLFxuICBcIlJlcXVlc3QgYm9keSBsYXJnZXIgdGhhbiBtYXhCb2R5TGVuZ3RoIGxpbWl0XCJcbik7XG52YXIgV3JpdGVBZnRlckVuZEVycm9yID0gY3JlYXRlRXJyb3JUeXBlKFxuICBcIkVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EXCIsXG4gIFwid3JpdGUgYWZ0ZXIgZW5kXCJcbik7XG5cbi8vIEFuIEhUVFAoUykgcmVxdWVzdCB0aGF0IGNhbiBiZSByZWRpcmVjdGVkXG5mdW5jdGlvbiBSZWRpcmVjdGFibGVSZXF1ZXN0KG9wdGlvbnMsIHJlc3BvbnNlQ2FsbGJhY2spIHtcbiAgLy8gSW5pdGlhbGl6ZSB0aGUgcmVxdWVzdFxuICBXcml0YWJsZS5jYWxsKHRoaXMpO1xuICB0aGlzLl9zYW5pdGl6ZU9wdGlvbnMob3B0aW9ucyk7XG4gIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLl9lbmRlZCA9IGZhbHNlO1xuICB0aGlzLl9lbmRpbmcgPSBmYWxzZTtcbiAgdGhpcy5fcmVkaXJlY3RDb3VudCA9IDA7XG4gIHRoaXMuX3JlZGlyZWN0cyA9IFtdO1xuICB0aGlzLl9yZXF1ZXN0Qm9keUxlbmd0aCA9IDA7XG4gIHRoaXMuX3JlcXVlc3RCb2R5QnVmZmVycyA9IFtdO1xuXG4gIC8vIEF0dGFjaCBhIGNhbGxiYWNrIGlmIHBhc3NlZFxuICBpZiAocmVzcG9uc2VDYWxsYmFjaykge1xuICAgIHRoaXMub24oXCJyZXNwb25zZVwiLCByZXNwb25zZUNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIFJlYWN0IHRvIHJlc3BvbnNlcyBvZiBuYXRpdmUgcmVxdWVzdHNcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9vbk5hdGl2ZVJlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgc2VsZi5fcHJvY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlKTtcbiAgfTtcblxuICAvLyBQZXJmb3JtIHRoZSBmaXJzdCByZXF1ZXN0XG4gIHRoaXMuX3BlcmZvcm1SZXF1ZXN0KCk7XG59XG5SZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoV3JpdGFibGUucHJvdG90eXBlKTtcblxuUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gIGFib3J0UmVxdWVzdCh0aGlzLl9jdXJyZW50UmVxdWVzdCk7XG4gIHRoaXMuZW1pdChcImFib3J0XCIpO1xufTtcblxuLy8gV3JpdGVzIGJ1ZmZlcmVkIGRhdGEgdG8gdGhlIGN1cnJlbnQgbmF0aXZlIHJlcXVlc3RcblJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAvLyBXcml0aW5nIGlzIG5vdCBhbGxvd2VkIGlmIGVuZCBoYXMgYmVlbiBjYWxsZWRcbiAgaWYgKHRoaXMuX2VuZGluZykge1xuICAgIHRocm93IG5ldyBXcml0ZUFmdGVyRW5kRXJyb3IoKTtcbiAgfVxuXG4gIC8vIFZhbGlkYXRlIGlucHV0IGFuZCBzaGlmdCBwYXJhbWV0ZXJzIGlmIG5lY2Vzc2FyeVxuICBpZiAoIWlzU3RyaW5nKGRhdGEpICYmICFpc0J1ZmZlcihkYXRhKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJkYXRhIHNob3VsZCBiZSBhIHN0cmluZywgQnVmZmVyIG9yIFVpbnQ4QXJyYXlcIik7XG4gIH1cbiAgaWYgKGlzRnVuY3Rpb24oZW5jb2RpbmcpKSB7XG4gICAgY2FsbGJhY2sgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICAvLyBJZ25vcmUgZW1wdHkgYnVmZmVycywgc2luY2Ugd3JpdGluZyB0aGVtIGRvZXNuJ3QgaW52b2tlIHRoZSBjYWxsYmFja1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzIyMDY2XG4gIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIE9ubHkgd3JpdGUgd2hlbiB3ZSBkb24ndCBleGNlZWQgdGhlIG1heGltdW0gYm9keSBsZW5ndGhcbiAgaWYgKHRoaXMuX3JlcXVlc3RCb2R5TGVuZ3RoICsgZGF0YS5sZW5ndGggPD0gdGhpcy5fb3B0aW9ucy5tYXhCb2R5TGVuZ3RoKSB7XG4gICAgdGhpcy5fcmVxdWVzdEJvZHlMZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgdGhpcy5fcmVxdWVzdEJvZHlCdWZmZXJzLnB1c2goeyBkYXRhOiBkYXRhLCBlbmNvZGluZzogZW5jb2RpbmcgfSk7XG4gICAgdGhpcy5fY3VycmVudFJlcXVlc3Qud3JpdGUoZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrKTtcbiAgfVxuICAvLyBFcnJvciB3aGVuIHdlIGV4Y2VlZCB0aGUgbWF4aW11bSBib2R5IGxlbmd0aFxuICBlbHNlIHtcbiAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBuZXcgTWF4Qm9keUxlbmd0aEV4Y2VlZGVkRXJyb3IoKSk7XG4gICAgdGhpcy5hYm9ydCgpO1xuICB9XG59O1xuXG4vLyBFbmRzIHRoZSBjdXJyZW50IG5hdGl2ZSByZXF1ZXN0XG5SZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gIC8vIFNoaWZ0IHBhcmFtZXRlcnMgaWYgbmVjZXNzYXJ5XG4gIGlmIChpc0Z1bmN0aW9uKGRhdGEpKSB7XG4gICAgY2FsbGJhY2sgPSBkYXRhO1xuICAgIGRhdGEgPSBlbmNvZGluZyA9IG51bGw7XG4gIH1cbiAgZWxzZSBpZiAoaXNGdW5jdGlvbihlbmNvZGluZykpIHtcbiAgICBjYWxsYmFjayA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIC8vIFdyaXRlIGRhdGEgaWYgbmVlZGVkIGFuZCBlbmRcbiAgaWYgKCFkYXRhKSB7XG4gICAgdGhpcy5fZW5kZWQgPSB0aGlzLl9lbmRpbmcgPSB0cnVlO1xuICAgIHRoaXMuX2N1cnJlbnRSZXF1ZXN0LmVuZChudWxsLCBudWxsLCBjYWxsYmFjayk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjdXJyZW50UmVxdWVzdCA9IHRoaXMuX2N1cnJlbnRSZXF1ZXN0O1xuICAgIHRoaXMud3JpdGUoZGF0YSwgZW5jb2RpbmcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuX2VuZGVkID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRSZXF1ZXN0LmVuZChudWxsLCBudWxsLCBjYWxsYmFjayk7XG4gICAgfSk7XG4gICAgdGhpcy5fZW5kaW5nID0gdHJ1ZTtcbiAgfVxufTtcblxuLy8gU2V0cyBhIGhlYWRlciB2YWx1ZSBvbiB0aGUgY3VycmVudCBuYXRpdmUgcmVxdWVzdFxuUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUuc2V0SGVhZGVyID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIHRoaXMuX29wdGlvbnMuaGVhZGVyc1tuYW1lXSA9IHZhbHVlO1xuICB0aGlzLl9jdXJyZW50UmVxdWVzdC5zZXRIZWFkZXIobmFtZSwgdmFsdWUpO1xufTtcblxuLy8gQ2xlYXJzIGEgaGVhZGVyIHZhbHVlIG9uIHRoZSBjdXJyZW50IG5hdGl2ZSByZXF1ZXN0XG5SZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZS5yZW1vdmVIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICBkZWxldGUgdGhpcy5fb3B0aW9ucy5oZWFkZXJzW25hbWVdO1xuICB0aGlzLl9jdXJyZW50UmVxdWVzdC5yZW1vdmVIZWFkZXIobmFtZSk7XG59O1xuXG4vLyBHbG9iYWwgdGltZW91dCBmb3IgYWxsIHVuZGVybHlpbmcgcmVxdWVzdHNcblJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlLnNldFRpbWVvdXQgPSBmdW5jdGlvbiAobXNlY3MsIGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBEZXN0cm95cyB0aGUgc29ja2V0IG9uIHRpbWVvdXRcbiAgZnVuY3Rpb24gZGVzdHJveU9uVGltZW91dChzb2NrZXQpIHtcbiAgICBzb2NrZXQuc2V0VGltZW91dChtc2Vjcyk7XG4gICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKFwidGltZW91dFwiLCBzb2NrZXQuZGVzdHJveSk7XG4gICAgc29ja2V0LmFkZExpc3RlbmVyKFwidGltZW91dFwiLCBzb2NrZXQuZGVzdHJveSk7XG4gIH1cblxuICAvLyBTZXRzIHVwIGEgdGltZXIgdG8gdHJpZ2dlciBhIHRpbWVvdXQgZXZlbnRcbiAgZnVuY3Rpb24gc3RhcnRUaW1lcihzb2NrZXQpIHtcbiAgICBpZiAoc2VsZi5fdGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX3RpbWVvdXQpO1xuICAgIH1cbiAgICBzZWxmLl90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmVtaXQoXCJ0aW1lb3V0XCIpO1xuICAgICAgY2xlYXJUaW1lcigpO1xuICAgIH0sIG1zZWNzKTtcbiAgICBkZXN0cm95T25UaW1lb3V0KHNvY2tldCk7XG4gIH1cblxuICAvLyBTdG9wcyBhIHRpbWVvdXQgZnJvbSB0cmlnZ2VyaW5nXG4gIGZ1bmN0aW9uIGNsZWFyVGltZXIoKSB7XG4gICAgLy8gQ2xlYXIgdGhlIHRpbWVvdXRcbiAgICBpZiAoc2VsZi5fdGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX3RpbWVvdXQpO1xuICAgICAgc2VsZi5fdGltZW91dCA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gQ2xlYW4gdXAgYWxsIGF0dGFjaGVkIGxpc3RlbmVyc1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoXCJhYm9ydFwiLCBjbGVhclRpbWVyKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgY2xlYXJUaW1lcik7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcihcInJlc3BvbnNlXCIsIGNsZWFyVGltZXIpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgc2VsZi5yZW1vdmVMaXN0ZW5lcihcInRpbWVvdXRcIiwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBpZiAoIXNlbGYuc29ja2V0KSB7XG4gICAgICBzZWxmLl9jdXJyZW50UmVxdWVzdC5yZW1vdmVMaXN0ZW5lcihcInNvY2tldFwiLCBzdGFydFRpbWVyKTtcbiAgICB9XG4gIH1cblxuICAvLyBBdHRhY2ggY2FsbGJhY2sgaWYgcGFzc2VkXG4gIGlmIChjYWxsYmFjaykge1xuICAgIHRoaXMub24oXCJ0aW1lb3V0XCIsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIFN0YXJ0IHRoZSB0aW1lciBpZiBvciB3aGVuIHRoZSBzb2NrZXQgaXMgb3BlbmVkXG4gIGlmICh0aGlzLnNvY2tldCkge1xuICAgIHN0YXJ0VGltZXIodGhpcy5zb2NrZXQpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuX2N1cnJlbnRSZXF1ZXN0Lm9uY2UoXCJzb2NrZXRcIiwgc3RhcnRUaW1lcik7XG4gIH1cblxuICAvLyBDbGVhbiB1cCBvbiBldmVudHNcbiAgdGhpcy5vbihcInNvY2tldFwiLCBkZXN0cm95T25UaW1lb3V0KTtcbiAgdGhpcy5vbihcImFib3J0XCIsIGNsZWFyVGltZXIpO1xuICB0aGlzLm9uKFwiZXJyb3JcIiwgY2xlYXJUaW1lcik7XG4gIHRoaXMub24oXCJyZXNwb25zZVwiLCBjbGVhclRpbWVyKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIFByb3h5IGFsbCBvdGhlciBwdWJsaWMgQ2xpZW50UmVxdWVzdCBtZXRob2RzXG5bXG4gIFwiZmx1c2hIZWFkZXJzXCIsIFwiZ2V0SGVhZGVyXCIsXG4gIFwic2V0Tm9EZWxheVwiLCBcInNldFNvY2tldEtlZXBBbGl2ZVwiLFxuXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRSZXF1ZXN0W21ldGhvZF0oYSwgYik7XG4gIH07XG59KTtcblxuLy8gUHJveHkgYWxsIHB1YmxpYyBDbGllbnRSZXF1ZXN0IHByb3BlcnRpZXNcbltcImFib3J0ZWRcIiwgXCJjb25uZWN0aW9uXCIsIFwic29ja2V0XCJdLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZSwgcHJvcGVydHksIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2N1cnJlbnRSZXF1ZXN0W3Byb3BlcnR5XTsgfSxcbiAgfSk7XG59KTtcblxuUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUuX3Nhbml0aXplT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIC8vIEVuc3VyZSBoZWFkZXJzIGFyZSBhbHdheXMgcHJlc2VudFxuICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgIG9wdGlvbnMuaGVhZGVycyA9IHt9O1xuICB9XG5cbiAgLy8gU2luY2UgaHR0cC5yZXF1ZXN0IHRyZWF0cyBob3N0IGFzIGFuIGFsaWFzIG9mIGhvc3RuYW1lLFxuICAvLyBidXQgdGhlIHVybCBtb2R1bGUgaW50ZXJwcmV0cyBob3N0IGFzIGhvc3RuYW1lIHBsdXMgcG9ydCxcbiAgLy8gZWxpbWluYXRlIHRoZSBob3N0IHByb3BlcnR5IHRvIGF2b2lkIGNvbmZ1c2lvbi5cbiAgaWYgKG9wdGlvbnMuaG9zdCkge1xuICAgIC8vIFVzZSBob3N0bmFtZSBpZiBzZXQsIGJlY2F1c2UgaXQgaGFzIHByZWNlZGVuY2VcbiAgICBpZiAoIW9wdGlvbnMuaG9zdG5hbWUpIHtcbiAgICAgIG9wdGlvbnMuaG9zdG5hbWUgPSBvcHRpb25zLmhvc3Q7XG4gICAgfVxuICAgIGRlbGV0ZSBvcHRpb25zLmhvc3Q7XG4gIH1cblxuICAvLyBDb21wbGV0ZSB0aGUgVVJMIG9iamVjdCB3aGVuIG5lY2Vzc2FyeVxuICBpZiAoIW9wdGlvbnMucGF0aG5hbWUgJiYgb3B0aW9ucy5wYXRoKSB7XG4gICAgdmFyIHNlYXJjaFBvcyA9IG9wdGlvbnMucGF0aC5pbmRleE9mKFwiP1wiKTtcbiAgICBpZiAoc2VhcmNoUG9zIDwgMCkge1xuICAgICAgb3B0aW9ucy5wYXRobmFtZSA9IG9wdGlvbnMucGF0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBvcHRpb25zLnBhdGhuYW1lID0gb3B0aW9ucy5wYXRoLnN1YnN0cmluZygwLCBzZWFyY2hQb3MpO1xuICAgICAgb3B0aW9ucy5zZWFyY2ggPSBvcHRpb25zLnBhdGguc3Vic3RyaW5nKHNlYXJjaFBvcyk7XG4gICAgfVxuICB9XG59O1xuXG5cbi8vIEV4ZWN1dGVzIHRoZSBuZXh0IG5hdGl2ZSByZXF1ZXN0IChpbml0aWFsIG9yIHJlZGlyZWN0KVxuUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUuX3BlcmZvcm1SZXF1ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBMb2FkIHRoZSBuYXRpdmUgcHJvdG9jb2xcbiAgdmFyIHByb3RvY29sID0gdGhpcy5fb3B0aW9ucy5wcm90b2NvbDtcbiAgdmFyIG5hdGl2ZVByb3RvY29sID0gdGhpcy5fb3B0aW9ucy5uYXRpdmVQcm90b2NvbHNbcHJvdG9jb2xdO1xuICBpZiAoIW5hdGl2ZVByb3RvY29sKSB7XG4gICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgbmV3IFR5cGVFcnJvcihcIlVuc3VwcG9ydGVkIHByb3RvY29sIFwiICsgcHJvdG9jb2wpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJZiBzcGVjaWZpZWQsIHVzZSB0aGUgYWdlbnQgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvdG9jb2xcbiAgLy8gKEhUVFAgYW5kIEhUVFBTIHVzZSBkaWZmZXJlbnQgdHlwZXMgb2YgYWdlbnRzKVxuICBpZiAodGhpcy5fb3B0aW9ucy5hZ2VudHMpIHtcbiAgICB2YXIgc2NoZW1lID0gcHJvdG9jb2wuc2xpY2UoMCwgLTEpO1xuICAgIHRoaXMuX29wdGlvbnMuYWdlbnQgPSB0aGlzLl9vcHRpb25zLmFnZW50c1tzY2hlbWVdO1xuICB9XG5cbiAgLy8gQ3JlYXRlIHRoZSBuYXRpdmUgcmVxdWVzdCBhbmQgc2V0IHVwIGl0cyBldmVudCBoYW5kbGVyc1xuICB2YXIgcmVxdWVzdCA9IHRoaXMuX2N1cnJlbnRSZXF1ZXN0ID1cbiAgICAgICAgbmF0aXZlUHJvdG9jb2wucmVxdWVzdCh0aGlzLl9vcHRpb25zLCB0aGlzLl9vbk5hdGl2ZVJlc3BvbnNlKTtcbiAgcmVxdWVzdC5fcmVkaXJlY3RhYmxlID0gdGhpcztcbiAgZm9yICh2YXIgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgcmVxdWVzdC5vbihldmVudCwgZXZlbnRIYW5kbGVyc1tldmVudF0pO1xuICB9XG5cbiAgLy8gUkZDNzIzMMKnNS4zLjE6IFdoZW4gbWFraW5nIGEgcmVxdWVzdCBkaXJlY3RseSB0byBhbiBvcmlnaW4gc2VydmVyLCBb4oCmXVxuICAvLyBhIGNsaWVudCBNVVNUIHNlbmQgb25seSB0aGUgYWJzb2x1dGUgcGF0aCBb4oCmXSBhcyB0aGUgcmVxdWVzdC10YXJnZXQuXG4gIHRoaXMuX2N1cnJlbnRVcmwgPSAvXlxcLy8udGVzdCh0aGlzLl9vcHRpb25zLnBhdGgpID9cbiAgICB1cmwuZm9ybWF0KHRoaXMuX29wdGlvbnMpIDpcbiAgICAvLyBXaGVuIG1ha2luZyBhIHJlcXVlc3QgdG8gYSBwcm94eSwgW+KApl1cbiAgICAvLyBhIGNsaWVudCBNVVNUIHNlbmQgdGhlIHRhcmdldCBVUkkgaW4gYWJzb2x1dGUtZm9ybSBb4oCmXS5cbiAgICB0aGlzLl9vcHRpb25zLnBhdGg7XG5cbiAgLy8gRW5kIGEgcmVkaXJlY3RlZCByZXF1ZXN0XG4gIC8vIChUaGUgZmlyc3QgcmVxdWVzdCBtdXN0IGJlIGVuZGVkIGV4cGxpY2l0bHkgd2l0aCBSZWRpcmVjdGFibGVSZXF1ZXN0I2VuZClcbiAgaWYgKHRoaXMuX2lzUmVkaXJlY3QpIHtcbiAgICAvLyBXcml0ZSB0aGUgcmVxdWVzdCBlbnRpdHkgYW5kIGVuZFxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGJ1ZmZlcnMgPSB0aGlzLl9yZXF1ZXN0Qm9keUJ1ZmZlcnM7XG4gICAgKGZ1bmN0aW9uIHdyaXRlTmV4dChlcnJvcikge1xuICAgICAgLy8gT25seSB3cml0ZSBpZiB0aGlzIHJlcXVlc3QgaGFzIG5vdCBiZWVuIHJlZGlyZWN0ZWQgeWV0XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHJlcXVlc3QgPT09IHNlbGYuX2N1cnJlbnRSZXF1ZXN0KSB7XG4gICAgICAgIC8vIFJlcG9ydCBhbnkgd3JpdGUgZXJyb3JzXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV3JpdGUgdGhlIG5leHQgYnVmZmVyIGlmIHRoZXJlIGFyZSBzdGlsbCBsZWZ0XG4gICAgICAgIGVsc2UgaWYgKGkgPCBidWZmZXJzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBidWZmZXIgPSBidWZmZXJzW2krK107XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICBpZiAoIXJlcXVlc3QuZmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJlcXVlc3Qud3JpdGUoYnVmZmVyLmRhdGEsIGJ1ZmZlci5lbmNvZGluZywgd3JpdGVOZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5kIHRoZSByZXF1ZXN0IGlmIGBlbmRgIGhhcyBiZWVuIGNhbGxlZCBvbiB1c1xuICAgICAgICBlbHNlIGlmIChzZWxmLl9lbmRlZCkge1xuICAgICAgICAgIHJlcXVlc3QuZW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KCkpO1xuICB9XG59O1xuXG4vLyBQcm9jZXNzZXMgYSByZXNwb25zZSBmcm9tIHRoZSBjdXJyZW50IG5hdGl2ZSByZXF1ZXN0XG5SZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZS5fcHJvY2Vzc1Jlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gIC8vIFN0b3JlIHRoZSByZWRpcmVjdGVkIHJlc3BvbnNlXG4gIHZhciBzdGF0dXNDb2RlID0gcmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgaWYgKHRoaXMuX29wdGlvbnMudHJhY2tSZWRpcmVjdHMpIHtcbiAgICB0aGlzLl9yZWRpcmVjdHMucHVzaCh7XG4gICAgICB1cmw6IHRoaXMuX2N1cnJlbnRVcmwsXG4gICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgc3RhdHVzQ29kZTogc3RhdHVzQ29kZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFJGQzcyMzHCpzYuNDogVGhlIDN4eCAoUmVkaXJlY3Rpb24pIGNsYXNzIG9mIHN0YXR1cyBjb2RlIGluZGljYXRlc1xuICAvLyB0aGF0IGZ1cnRoZXIgYWN0aW9uIG5lZWRzIHRvIGJlIHRha2VuIGJ5IHRoZSB1c2VyIGFnZW50IGluIG9yZGVyIHRvXG4gIC8vIGZ1bGZpbGwgdGhlIHJlcXVlc3QuIElmIGEgTG9jYXRpb24gaGVhZGVyIGZpZWxkIGlzIHByb3ZpZGVkLFxuICAvLyB0aGUgdXNlciBhZ2VudCBNQVkgYXV0b21hdGljYWxseSByZWRpcmVjdCBpdHMgcmVxdWVzdCB0byB0aGUgVVJJXG4gIC8vIHJlZmVyZW5jZWQgYnkgdGhlIExvY2F0aW9uIGZpZWxkIHZhbHVlLFxuICAvLyBldmVuIGlmIHRoZSBzcGVjaWZpYyBzdGF0dXMgY29kZSBpcyBub3QgdW5kZXJzdG9vZC5cblxuICAvLyBJZiB0aGUgcmVzcG9uc2UgaXMgbm90IGEgcmVkaXJlY3Q7IHJldHVybiBpdCBhcy1pc1xuICB2YXIgbG9jYXRpb24gPSByZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uO1xuICBpZiAoIWxvY2F0aW9uIHx8IHRoaXMuX29wdGlvbnMuZm9sbG93UmVkaXJlY3RzID09PSBmYWxzZSB8fFxuICAgICAgc3RhdHVzQ29kZSA8IDMwMCB8fCBzdGF0dXNDb2RlID49IDQwMCkge1xuICAgIHJlc3BvbnNlLnJlc3BvbnNlVXJsID0gdGhpcy5fY3VycmVudFVybDtcbiAgICByZXNwb25zZS5yZWRpcmVjdHMgPSB0aGlzLl9yZWRpcmVjdHM7XG4gICAgdGhpcy5lbWl0KFwicmVzcG9uc2VcIiwgcmVzcG9uc2UpO1xuXG4gICAgLy8gQ2xlYW4gdXBcbiAgICB0aGlzLl9yZXF1ZXN0Qm9keUJ1ZmZlcnMgPSBbXTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBUaGUgcmVzcG9uc2UgaXMgYSByZWRpcmVjdCwgc28gYWJvcnQgdGhlIGN1cnJlbnQgcmVxdWVzdFxuICBhYm9ydFJlcXVlc3QodGhpcy5fY3VycmVudFJlcXVlc3QpO1xuICAvLyBEaXNjYXJkIHRoZSByZW1haW5kZXIgb2YgdGhlIHJlc3BvbnNlIHRvIGF2b2lkIHdhaXRpbmcgZm9yIGRhdGFcbiAgcmVzcG9uc2UuZGVzdHJveSgpO1xuXG4gIC8vIFJGQzcyMzHCpzYuNDogQSBjbGllbnQgU0hPVUxEIGRldGVjdCBhbmQgaW50ZXJ2ZW5lXG4gIC8vIGluIGN5Y2xpY2FsIHJlZGlyZWN0aW9ucyAoaS5lLiwgXCJpbmZpbml0ZVwiIHJlZGlyZWN0aW9uIGxvb3BzKS5cbiAgaWYgKCsrdGhpcy5fcmVkaXJlY3RDb3VudCA+IHRoaXMuX29wdGlvbnMubWF4UmVkaXJlY3RzKSB7XG4gICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgbmV3IFRvb01hbnlSZWRpcmVjdHNFcnJvcigpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBTdG9yZSB0aGUgcmVxdWVzdCBoZWFkZXJzIGlmIGFwcGxpY2FibGVcbiAgdmFyIHJlcXVlc3RIZWFkZXJzO1xuICB2YXIgYmVmb3JlUmVkaXJlY3QgPSB0aGlzLl9vcHRpb25zLmJlZm9yZVJlZGlyZWN0O1xuICBpZiAoYmVmb3JlUmVkaXJlY3QpIHtcbiAgICByZXF1ZXN0SGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgLy8gVGhlIEhvc3QgaGVhZGVyIHdhcyBzZXQgYnkgbmF0aXZlUHJvdG9jb2wucmVxdWVzdFxuICAgICAgSG9zdDogcmVzcG9uc2UucmVxLmdldEhlYWRlcihcImhvc3RcIiksXG4gICAgfSwgdGhpcy5fb3B0aW9ucy5oZWFkZXJzKTtcbiAgfVxuXG4gIC8vIFJGQzcyMzHCpzYuNDogQXV0b21hdGljIHJlZGlyZWN0aW9uIG5lZWRzIHRvIGRvbmUgd2l0aFxuICAvLyBjYXJlIGZvciBtZXRob2RzIG5vdCBrbm93biB0byBiZSBzYWZlLCBb4oCmXVxuICAvLyBSRkM3MjMxwqc2LjQuMuKAkzM6IEZvciBoaXN0b3JpY2FsIHJlYXNvbnMsIGEgdXNlciBhZ2VudCBNQVkgY2hhbmdlXG4gIC8vIHRoZSByZXF1ZXN0IG1ldGhvZCBmcm9tIFBPU1QgdG8gR0VUIGZvciB0aGUgc3Vic2VxdWVudCByZXF1ZXN0LlxuICB2YXIgbWV0aG9kID0gdGhpcy5fb3B0aW9ucy5tZXRob2Q7XG4gIGlmICgoc3RhdHVzQ29kZSA9PT0gMzAxIHx8IHN0YXR1c0NvZGUgPT09IDMwMikgJiYgdGhpcy5fb3B0aW9ucy5tZXRob2QgPT09IFwiUE9TVFwiIHx8XG4gICAgICAvLyBSRkM3MjMxwqc2LjQuNDogVGhlIDMwMyAoU2VlIE90aGVyKSBzdGF0dXMgY29kZSBpbmRpY2F0ZXMgdGhhdFxuICAgICAgLy8gdGhlIHNlcnZlciBpcyByZWRpcmVjdGluZyB0aGUgdXNlciBhZ2VudCB0byBhIGRpZmZlcmVudCByZXNvdXJjZSBb4oCmXVxuICAgICAgLy8gQSB1c2VyIGFnZW50IGNhbiBwZXJmb3JtIGEgcmV0cmlldmFsIHJlcXVlc3QgdGFyZ2V0aW5nIHRoYXQgVVJJXG4gICAgICAvLyAoYSBHRVQgb3IgSEVBRCByZXF1ZXN0IGlmIHVzaW5nIEhUVFApIFvigKZdXG4gICAgICAoc3RhdHVzQ29kZSA9PT0gMzAzKSAmJiAhL14oPzpHRVR8SEVBRCkkLy50ZXN0KHRoaXMuX29wdGlvbnMubWV0aG9kKSkge1xuICAgIHRoaXMuX29wdGlvbnMubWV0aG9kID0gXCJHRVRcIjtcbiAgICAvLyBEcm9wIGEgcG9zc2libGUgZW50aXR5IGFuZCBoZWFkZXJzIHJlbGF0ZWQgdG8gaXRcbiAgICB0aGlzLl9yZXF1ZXN0Qm9keUJ1ZmZlcnMgPSBbXTtcbiAgICByZW1vdmVNYXRjaGluZ0hlYWRlcnMoL15jb250ZW50LS9pLCB0aGlzLl9vcHRpb25zLmhlYWRlcnMpO1xuICB9XG5cbiAgLy8gRHJvcCB0aGUgSG9zdCBoZWFkZXIsIGFzIHRoZSByZWRpcmVjdCBtaWdodCBsZWFkIHRvIGEgZGlmZmVyZW50IGhvc3RcbiAgdmFyIGN1cnJlbnRIb3N0SGVhZGVyID0gcmVtb3ZlTWF0Y2hpbmdIZWFkZXJzKC9eaG9zdCQvaSwgdGhpcy5fb3B0aW9ucy5oZWFkZXJzKTtcblxuICAvLyBJZiB0aGUgcmVkaXJlY3QgaXMgcmVsYXRpdmUsIGNhcnJ5IG92ZXIgdGhlIGhvc3Qgb2YgdGhlIGxhc3QgcmVxdWVzdFxuICB2YXIgY3VycmVudFVybFBhcnRzID0gdXJsLnBhcnNlKHRoaXMuX2N1cnJlbnRVcmwpO1xuICB2YXIgY3VycmVudEhvc3QgPSBjdXJyZW50SG9zdEhlYWRlciB8fCBjdXJyZW50VXJsUGFydHMuaG9zdDtcbiAgdmFyIGN1cnJlbnRVcmwgPSAvXlxcdys6Ly50ZXN0KGxvY2F0aW9uKSA/IHRoaXMuX2N1cnJlbnRVcmwgOlxuICAgIHVybC5mb3JtYXQoT2JqZWN0LmFzc2lnbihjdXJyZW50VXJsUGFydHMsIHsgaG9zdDogY3VycmVudEhvc3QgfSkpO1xuXG4gIC8vIERldGVybWluZSB0aGUgVVJMIG9mIHRoZSByZWRpcmVjdGlvblxuICB2YXIgcmVkaXJlY3RVcmw7XG4gIHRyeSB7XG4gICAgcmVkaXJlY3RVcmwgPSB1cmwucmVzb2x2ZShjdXJyZW50VXJsLCBsb2NhdGlvbik7XG4gIH1cbiAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgbmV3IFJlZGlyZWN0aW9uRXJyb3IoeyBjYXVzZTogY2F1c2UgfSkpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIENyZWF0ZSB0aGUgcmVkaXJlY3RlZCByZXF1ZXN0XG4gIGRlYnVnKFwicmVkaXJlY3RpbmcgdG9cIiwgcmVkaXJlY3RVcmwpO1xuICB0aGlzLl9pc1JlZGlyZWN0ID0gdHJ1ZTtcbiAgdmFyIHJlZGlyZWN0VXJsUGFydHMgPSB1cmwucGFyc2UocmVkaXJlY3RVcmwpO1xuICBPYmplY3QuYXNzaWduKHRoaXMuX29wdGlvbnMsIHJlZGlyZWN0VXJsUGFydHMpO1xuXG4gIC8vIERyb3AgY29uZmlkZW50aWFsIGhlYWRlcnMgd2hlbiByZWRpcmVjdGluZyB0byBhIGxlc3Mgc2VjdXJlIHByb3RvY29sXG4gIC8vIG9yIHRvIGEgZGlmZmVyZW50IGRvbWFpbiB0aGF0IGlzIG5vdCBhIHN1cGVyZG9tYWluXG4gIGlmIChyZWRpcmVjdFVybFBhcnRzLnByb3RvY29sICE9PSBjdXJyZW50VXJsUGFydHMucHJvdG9jb2wgJiZcbiAgICAgcmVkaXJlY3RVcmxQYXJ0cy5wcm90b2NvbCAhPT0gXCJodHRwczpcIiB8fFxuICAgICByZWRpcmVjdFVybFBhcnRzLmhvc3QgIT09IGN1cnJlbnRIb3N0ICYmXG4gICAgICFpc1N1YmRvbWFpbihyZWRpcmVjdFVybFBhcnRzLmhvc3QsIGN1cnJlbnRIb3N0KSkge1xuICAgIHJlbW92ZU1hdGNoaW5nSGVhZGVycygvXig/OmF1dGhvcml6YXRpb258Y29va2llKSQvaSwgdGhpcy5fb3B0aW9ucy5oZWFkZXJzKTtcbiAgfVxuXG4gIC8vIEV2YWx1YXRlIHRoZSBiZWZvcmVSZWRpcmVjdCBjYWxsYmFja1xuICBpZiAoaXNGdW5jdGlvbihiZWZvcmVSZWRpcmVjdCkpIHtcbiAgICB2YXIgcmVzcG9uc2VEZXRhaWxzID0ge1xuICAgICAgaGVhZGVyczogcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgIHN0YXR1c0NvZGU6IHN0YXR1c0NvZGUsXG4gICAgfTtcbiAgICB2YXIgcmVxdWVzdERldGFpbHMgPSB7XG4gICAgICB1cmw6IGN1cnJlbnRVcmwsXG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIGhlYWRlcnM6IHJlcXVlc3RIZWFkZXJzLFxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGJlZm9yZVJlZGlyZWN0KHRoaXMuX29wdGlvbnMsIHJlc3BvbnNlRGV0YWlscywgcmVxdWVzdERldGFpbHMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9zYW5pdGl6ZU9wdGlvbnModGhpcy5fb3B0aW9ucyk7XG4gIH1cblxuICAvLyBQZXJmb3JtIHRoZSByZWRpcmVjdGVkIHJlcXVlc3RcbiAgdHJ5IHtcbiAgICB0aGlzLl9wZXJmb3JtUmVxdWVzdCgpO1xuICB9XG4gIGNhdGNoIChjYXVzZSkge1xuICAgIHRoaXMuZW1pdChcImVycm9yXCIsIG5ldyBSZWRpcmVjdGlvbkVycm9yKHsgY2F1c2U6IGNhdXNlIH0pKTtcbiAgfVxufTtcblxuLy8gV3JhcHMgdGhlIGtleS92YWx1ZSBvYmplY3Qgb2YgcHJvdG9jb2xzIHdpdGggcmVkaXJlY3QgZnVuY3Rpb25hbGl0eVxuZnVuY3Rpb24gd3JhcChwcm90b2NvbHMpIHtcbiAgLy8gRGVmYXVsdCBzZXR0aW5nc1xuICB2YXIgZXhwb3J0cyA9IHtcbiAgICBtYXhSZWRpcmVjdHM6IDIxLFxuICAgIG1heEJvZHlMZW5ndGg6IDEwICogMTAyNCAqIDEwMjQsXG4gIH07XG5cbiAgLy8gV3JhcCBlYWNoIHByb3RvY29sXG4gIHZhciBuYXRpdmVQcm90b2NvbHMgPSB7fTtcbiAgT2JqZWN0LmtleXMocHJvdG9jb2xzKS5mb3JFYWNoKGZ1bmN0aW9uIChzY2hlbWUpIHtcbiAgICB2YXIgcHJvdG9jb2wgPSBzY2hlbWUgKyBcIjpcIjtcbiAgICB2YXIgbmF0aXZlUHJvdG9jb2wgPSBuYXRpdmVQcm90b2NvbHNbcHJvdG9jb2xdID0gcHJvdG9jb2xzW3NjaGVtZV07XG4gICAgdmFyIHdyYXBwZWRQcm90b2NvbCA9IGV4cG9ydHNbc2NoZW1lXSA9IE9iamVjdC5jcmVhdGUobmF0aXZlUHJvdG9jb2wpO1xuXG4gICAgLy8gRXhlY3V0ZXMgYSByZXF1ZXN0LCBmb2xsb3dpbmcgcmVkaXJlY3RzXG4gICAgZnVuY3Rpb24gcmVxdWVzdChpbnB1dCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgIC8vIFBhcnNlIHBhcmFtZXRlcnNcbiAgICAgIGlmIChpc1N0cmluZyhpbnB1dCkpIHtcbiAgICAgICAgdmFyIHBhcnNlZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwYXJzZWQgPSB1cmxUb09wdGlvbnMobmV3IFVSTChpbnB1dCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIHBhcnNlZCA9IHVybC5wYXJzZShpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1N0cmluZyhwYXJzZWQucHJvdG9jb2wpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRVcmxFcnJvcih7IGlucHV0IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0ID0gcGFyc2VkO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoVVJMICYmIChpbnB1dCBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICAgICAgaW5wdXQgPSB1cmxUb09wdGlvbnMoaW5wdXQpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IGlucHV0O1xuICAgICAgICBpbnB1dCA9IHsgcHJvdG9jb2w6IHByb3RvY29sIH07XG4gICAgICB9XG4gICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zKSkge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgZGVmYXVsdHNcbiAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgbWF4UmVkaXJlY3RzOiBleHBvcnRzLm1heFJlZGlyZWN0cyxcbiAgICAgICAgbWF4Qm9keUxlbmd0aDogZXhwb3J0cy5tYXhCb2R5TGVuZ3RoLFxuICAgICAgfSwgaW5wdXQsIG9wdGlvbnMpO1xuICAgICAgb3B0aW9ucy5uYXRpdmVQcm90b2NvbHMgPSBuYXRpdmVQcm90b2NvbHM7XG4gICAgICBpZiAoIWlzU3RyaW5nKG9wdGlvbnMuaG9zdCkgJiYgIWlzU3RyaW5nKG9wdGlvbnMuaG9zdG5hbWUpKSB7XG4gICAgICAgIG9wdGlvbnMuaG9zdG5hbWUgPSBcIjo6MVwiO1xuICAgICAgfVxuXG4gICAgICBhc3NlcnQuZXF1YWwob3B0aW9ucy5wcm90b2NvbCwgcHJvdG9jb2wsIFwicHJvdG9jb2wgbWlzbWF0Y2hcIik7XG4gICAgICBkZWJ1ZyhcIm9wdGlvbnNcIiwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gbmV3IFJlZGlyZWN0YWJsZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8vIEV4ZWN1dGVzIGEgR0VUIHJlcXVlc3QsIGZvbGxvd2luZyByZWRpcmVjdHNcbiAgICBmdW5jdGlvbiBnZXQoaW5wdXQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgd3JhcHBlZFJlcXVlc3QgPSB3cmFwcGVkUHJvdG9jb2wucmVxdWVzdChpbnB1dCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgd3JhcHBlZFJlcXVlc3QuZW5kKCk7XG4gICAgICByZXR1cm4gd3JhcHBlZFJlcXVlc3Q7XG4gICAgfVxuXG4gICAgLy8gRXhwb3NlIHRoZSBwcm9wZXJ0aWVzIG9uIHRoZSB3cmFwcGVkIHByb3RvY29sXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMod3JhcHBlZFByb3RvY29sLCB7XG4gICAgICByZXF1ZXN0OiB7IHZhbHVlOiByZXF1ZXN0LCBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0sXG4gICAgICBnZXQ6IHsgdmFsdWU6IGdldCwgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9LFxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGV4cG9ydHM7XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBub29wKCkgeyAvKiBlbXB0eSAqLyB9XG5cbi8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFzdGVyL2xpYi9pbnRlcm5hbC91cmwuanNcbmZ1bmN0aW9uIHVybFRvT3B0aW9ucyh1cmxPYmplY3QpIHtcbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgcHJvdG9jb2w6IHVybE9iamVjdC5wcm90b2NvbCxcbiAgICBob3N0bmFtZTogdXJsT2JqZWN0Lmhvc3RuYW1lLnN0YXJ0c1dpdGgoXCJbXCIpID9cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICB1cmxPYmplY3QuaG9zdG5hbWUuc2xpY2UoMSwgLTEpIDpcbiAgICAgIHVybE9iamVjdC5ob3N0bmFtZSxcbiAgICBoYXNoOiB1cmxPYmplY3QuaGFzaCxcbiAgICBzZWFyY2g6IHVybE9iamVjdC5zZWFyY2gsXG4gICAgcGF0aG5hbWU6IHVybE9iamVjdC5wYXRobmFtZSxcbiAgICBwYXRoOiB1cmxPYmplY3QucGF0aG5hbWUgKyB1cmxPYmplY3Quc2VhcmNoLFxuICAgIGhyZWY6IHVybE9iamVjdC5ocmVmLFxuICB9O1xuICBpZiAodXJsT2JqZWN0LnBvcnQgIT09IFwiXCIpIHtcbiAgICBvcHRpb25zLnBvcnQgPSBOdW1iZXIodXJsT2JqZWN0LnBvcnQpO1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG5mdW5jdGlvbiByZW1vdmVNYXRjaGluZ0hlYWRlcnMocmVnZXgsIGhlYWRlcnMpIHtcbiAgdmFyIGxhc3RWYWx1ZTtcbiAgZm9yICh2YXIgaGVhZGVyIGluIGhlYWRlcnMpIHtcbiAgICBpZiAocmVnZXgudGVzdChoZWFkZXIpKSB7XG4gICAgICBsYXN0VmFsdWUgPSBoZWFkZXJzW2hlYWRlcl07XG4gICAgICBkZWxldGUgaGVhZGVyc1toZWFkZXJdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKGxhc3RWYWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgbGFzdFZhbHVlID09PSBcInVuZGVmaW5lZFwiKSA/XG4gICAgdW5kZWZpbmVkIDogU3RyaW5nKGxhc3RWYWx1ZSkudHJpbSgpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFcnJvclR5cGUoY29kZSwgbWVzc2FnZSwgYmFzZUNsYXNzKSB7XG4gIC8vIENyZWF0ZSBjb25zdHJ1Y3RvclxuICBmdW5jdGlvbiBDdXN0b21FcnJvcihwcm9wZXJ0aWVzKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBwcm9wZXJ0aWVzIHx8IHt9KTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMubWVzc2FnZSA9IHRoaXMuY2F1c2UgPyBtZXNzYWdlICsgXCI6IFwiICsgdGhpcy5jYXVzZS5tZXNzYWdlIDogbWVzc2FnZTtcbiAgfVxuXG4gIC8vIEF0dGFjaCBjb25zdHJ1Y3RvciBhbmQgc2V0IGRlZmF1bHQgcHJvcGVydGllc1xuICBDdXN0b21FcnJvci5wcm90b3R5cGUgPSBuZXcgKGJhc2VDbGFzcyB8fCBFcnJvcikoKTtcbiAgQ3VzdG9tRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ3VzdG9tRXJyb3I7XG4gIEN1c3RvbUVycm9yLnByb3RvdHlwZS5uYW1lID0gXCJFcnJvciBbXCIgKyBjb2RlICsgXCJdXCI7XG4gIHJldHVybiBDdXN0b21FcnJvcjtcbn1cblxuZnVuY3Rpb24gYWJvcnRSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgZm9yICh2YXIgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcihldmVudCwgZXZlbnRIYW5kbGVyc1tldmVudF0pO1xuICB9XG4gIHJlcXVlc3Qub24oXCJlcnJvclwiLCBub29wKTtcbiAgcmVxdWVzdC5hYm9ydCgpO1xufVxuXG5mdW5jdGlvbiBpc1N1YmRvbWFpbihzdWJkb21haW4sIGRvbWFpbikge1xuICBhc3NlcnQoaXNTdHJpbmcoc3ViZG9tYWluKSAmJiBpc1N0cmluZyhkb21haW4pKTtcbiAgdmFyIGRvdCA9IHN1YmRvbWFpbi5sZW5ndGggLSBkb21haW4ubGVuZ3RoIC0gMTtcbiAgcmV0dXJuIGRvdCA+IDAgJiYgc3ViZG9tYWluW2RvdF0gPT09IFwiLlwiICYmIHN1YmRvbWFpbi5lbmRzV2l0aChkb21haW4pO1xufVxuXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAoXCJsZW5ndGhcIiBpbiB2YWx1ZSk7XG59XG5cbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gd3JhcCh7IGh0dHA6IGh0dHAsIGh0dHBzOiBodHRwcyB9KTtcbm1vZHVsZS5leHBvcnRzLndyYXAgPSB3cmFwO1xuIl0sIm5hbWVzIjpbInVybCIsInJlcXVpcmUiLCJVUkwiLCJodHRwIiwiaHR0cHMiLCJXcml0YWJsZSIsImFzc2VydCIsImRlYnVnIiwiZXZlbnRzIiwiZXZlbnRIYW5kbGVycyIsIk9iamVjdCIsImNyZWF0ZSIsImZvckVhY2giLCJldmVudCIsImFyZzEiLCJhcmcyIiwiYXJnMyIsIl9yZWRpcmVjdGFibGUiLCJlbWl0IiwiSW52YWxpZFVybEVycm9yIiwiY3JlYXRlRXJyb3JUeXBlIiwiVHlwZUVycm9yIiwiUmVkaXJlY3Rpb25FcnJvciIsIlRvb01hbnlSZWRpcmVjdHNFcnJvciIsIk1heEJvZHlMZW5ndGhFeGNlZWRlZEVycm9yIiwiV3JpdGVBZnRlckVuZEVycm9yIiwiUmVkaXJlY3RhYmxlUmVxdWVzdCIsIm9wdGlvbnMiLCJyZXNwb25zZUNhbGxiYWNrIiwiY2FsbCIsIl9zYW5pdGl6ZU9wdGlvbnMiLCJfb3B0aW9ucyIsIl9lbmRlZCIsIl9lbmRpbmciLCJfcmVkaXJlY3RDb3VudCIsIl9yZWRpcmVjdHMiLCJfcmVxdWVzdEJvZHlMZW5ndGgiLCJfcmVxdWVzdEJvZHlCdWZmZXJzIiwib24iLCJzZWxmIiwiX29uTmF0aXZlUmVzcG9uc2UiLCJyZXNwb25zZSIsIl9wcm9jZXNzUmVzcG9uc2UiLCJfcGVyZm9ybVJlcXVlc3QiLCJwcm90b3R5cGUiLCJhYm9ydCIsImFib3J0UmVxdWVzdCIsIl9jdXJyZW50UmVxdWVzdCIsIndyaXRlIiwiZGF0YSIsImVuY29kaW5nIiwiY2FsbGJhY2siLCJpc1N0cmluZyIsImlzQnVmZmVyIiwiaXNGdW5jdGlvbiIsImxlbmd0aCIsIm1heEJvZHlMZW5ndGgiLCJwdXNoIiwiZW5kIiwiY3VycmVudFJlcXVlc3QiLCJzZXRIZWFkZXIiLCJuYW1lIiwidmFsdWUiLCJoZWFkZXJzIiwicmVtb3ZlSGVhZGVyIiwic2V0VGltZW91dCIsIm1zZWNzIiwiZGVzdHJveU9uVGltZW91dCIsInNvY2tldCIsInJlbW92ZUxpc3RlbmVyIiwiZGVzdHJveSIsImFkZExpc3RlbmVyIiwic3RhcnRUaW1lciIsIl90aW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiY2xlYXJUaW1lciIsIm9uY2UiLCJtZXRob2QiLCJhIiwiYiIsInByb3BlcnR5IiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJob3N0IiwiaG9zdG5hbWUiLCJwYXRobmFtZSIsInBhdGgiLCJzZWFyY2hQb3MiLCJpbmRleE9mIiwic3Vic3RyaW5nIiwic2VhcmNoIiwicHJvdG9jb2wiLCJuYXRpdmVQcm90b2NvbCIsIm5hdGl2ZVByb3RvY29scyIsImFnZW50cyIsInNjaGVtZSIsInNsaWNlIiwiYWdlbnQiLCJyZXF1ZXN0IiwiX2N1cnJlbnRVcmwiLCJ0ZXN0IiwiZm9ybWF0IiwiX2lzUmVkaXJlY3QiLCJpIiwiYnVmZmVycyIsIndyaXRlTmV4dCIsImVycm9yIiwiYnVmZmVyIiwiZmluaXNoZWQiLCJzdGF0dXNDb2RlIiwidHJhY2tSZWRpcmVjdHMiLCJsb2NhdGlvbiIsImZvbGxvd1JlZGlyZWN0cyIsInJlc3BvbnNlVXJsIiwicmVkaXJlY3RzIiwibWF4UmVkaXJlY3RzIiwicmVxdWVzdEhlYWRlcnMiLCJiZWZvcmVSZWRpcmVjdCIsImFzc2lnbiIsIkhvc3QiLCJyZXEiLCJnZXRIZWFkZXIiLCJyZW1vdmVNYXRjaGluZ0hlYWRlcnMiLCJjdXJyZW50SG9zdEhlYWRlciIsImN1cnJlbnRVcmxQYXJ0cyIsInBhcnNlIiwiY3VycmVudEhvc3QiLCJjdXJyZW50VXJsIiwicmVkaXJlY3RVcmwiLCJyZXNvbHZlIiwiY2F1c2UiLCJyZWRpcmVjdFVybFBhcnRzIiwiaXNTdWJkb21haW4iLCJyZXNwb25zZURldGFpbHMiLCJyZXF1ZXN0RGV0YWlscyIsImVyciIsIndyYXAiLCJwcm90b2NvbHMiLCJleHBvcnRzIiwia2V5cyIsIndyYXBwZWRQcm90b2NvbCIsImlucHV0IiwicGFyc2VkIiwidXJsVG9PcHRpb25zIiwiZXF1YWwiLCJ3cmFwcGVkUmVxdWVzdCIsImRlZmluZVByb3BlcnRpZXMiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJub29wIiwidXJsT2JqZWN0Iiwic3RhcnRzV2l0aCIsImhhc2giLCJocmVmIiwicG9ydCIsIk51bWJlciIsInJlZ2V4IiwibGFzdFZhbHVlIiwiaGVhZGVyIiwidW5kZWZpbmVkIiwiU3RyaW5nIiwidHJpbSIsImNvZGUiLCJtZXNzYWdlIiwiYmFzZUNsYXNzIiwiQ3VzdG9tRXJyb3IiLCJwcm9wZXJ0aWVzIiwiRXJyb3IiLCJjYXB0dXJlU3RhY2tUcmFjZSIsImNvbnN0cnVjdG9yIiwic3ViZG9tYWluIiwiZG9tYWluIiwiZG90IiwiZW5kc1dpdGgiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/follow-redirects/index.js\n");

/***/ })

};
;